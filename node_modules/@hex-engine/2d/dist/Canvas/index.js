import { useNewComponent, useType, RunLoop, useCallbackAsCurrent } from "@hex-engine/core";
import Inspector from "@hex-engine/inspector";
import { DrawChildren, useRawDraw } from "./DrawChildren";
import DrawOrder, { useDebugOverlayDrawTime, useCanvasDrawOrderSort } from "./DrawOrder";
import polyfillContext from "./polyfillContext";
import useCanvasSize from "../Hooks/useCanvasSize";
import useWindowSize from "../Hooks/useWindowSize";
import { setContext } from "../Hooks/useContext";
/** The built-in Canvas component that should be placed on your root Entity in order to render everything in your game. */

export default Object.assign(function Canvas(options) {
  useType(Canvas);
  var backgroundColor = options.backgroundColor;
  var canvas;

  if (options.element) {
    canvas = options.element;
  } else {
    canvas = document.createElement("canvas");
    document.body.appendChild(canvas);
    canvas.style.userSelect = "none"; // @ts-ignore this property was removed in TypeScript 3.9

    canvas.style.msUserSelect = "none";
    canvas.style.webkitUserSelect = "none";
  }

  canvas.className = canvas.className + " " + "hex-engine";
  canvas.addEventListener("contextmenu", function (event) {
    return event.preventDefault();
  });
  var context = canvas.getContext("2d");

  if (context == null) {
    throw new Error("2d drawing context type not supported by browser");
  }

  polyfillContext(context);
  setContext(context);
  useNewComponent(RunLoop);
  useNewComponent(function () {
    return DrawChildren({
      backgroundColor: backgroundColor
    });
  });

  if (process.env.NODE_ENV !== "production") {
    useNewComponent(function () {
      return Inspector();
    });
  }

  var preDraw = function preDraw() {};

  useRawDraw(function (context) {
    preDraw(context);
  });

  function setPixelated(on) {
    if (on) {
      canvas.style.imageRendering = navigator.userAgent.match(/firefox/i) ? "-moz-crisp-edges" : "pixelated";

      preDraw = function preDraw(context) {
        ["imageSmoothingEnabled", "mozImageSmoothingEnabled", "oImageSmoothingEnabled", "webkitImageSmoothingEnabled", "msImageSmoothingEnabled"].forEach(function (property) {
          // @ts-ignore
          context[property] = false;
        });
      };
    } else {
      canvas.style.imageRendering = "";

      preDraw = function preDraw(context) {
        ["imageSmoothingEnabled", "mozImageSmoothingEnabled", "oImageSmoothingEnabled", "webkitImageSmoothingEnabled", "msImageSmoothingEnabled"].forEach(function (property) {
          // @ts-ignore
          context[property] = true;
        });
      };
    }
  }

  setPixelated(true);

  var _useCanvasSize = useCanvasSize(),
      resizeCanvas = _useCanvasSize.resizeCanvas;

  return {
    element: canvas,
    context: context,
    setPixelated: setPixelated,
    resize: resizeCanvas,
    fullscreen: useCallbackAsCurrent(function () {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$pixelZoom = _ref.pixelZoom,
          pixelZoom = _ref$pixelZoom === void 0 ? 1 : _ref$pixelZoom;

      var _useWindowSize = useWindowSize(),
          windowSize = _useWindowSize.windowSize,
          onWindowResize = _useWindowSize.onWindowResize;

      var doc = canvas.ownerDocument;

      if (doc) {
        Object.assign(doc.body.style, {
          margin: 0,
          padding: 0,
          overflow: "hidden"
        });
      }

      var matchWindowSize = function matchWindowSize() {
        resizeCanvas({
          realWidth: windowSize.x,
          realHeight: windowSize.y,
          pixelWidth: windowSize.x / pixelZoom,
          pixelHeight: windowSize.y / pixelZoom
        });
      };

      onWindowResize(matchWindowSize);
      matchWindowSize();
    })
  };
}, {
  DrawOrder: DrawOrder
});
export { useRawDraw, useDebugOverlayDrawTime, useCanvasDrawOrderSort };