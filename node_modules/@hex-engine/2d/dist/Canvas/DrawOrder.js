function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

import { useType, useRootEntity, useCurrentComponent, useNewRootComponent } from "@hex-engine/core";

function StorageForDebugOverlayDrawTime() {
  useType(StorageForDebugOverlayDrawTime);
  return {
    componentsWithDebugOverlayDrawTime: new WeakMap()
  };
}
/**
 * This hook specifies to the default draw order sort function
 * that this Component's draw callbacks should be drawn last,
 * after everything else, because this component renders debug overlay(s)
 * that should be drawn on top of everything else.
 *
 * If you are using a custom draw order sort and want to preserve this functionality,
 * you can use the `Canvas.DrawOrder.isDebugOverlay` function to identify Components
 * that have called this hook.
 */


export function useDebugOverlayDrawTime() {
  var storage = useRootEntity().getComponent(StorageForDebugOverlayDrawTime) || useNewRootComponent(StorageForDebugOverlayDrawTime);
  storage.componentsWithDebugOverlayDrawTime.set(useCurrentComponent(), true);
}
/**
 * Returns a boolean indicating whether the specified Component has called the useDebugOverlayDrawTime hook.
 * @param component The Component to check.
 * @param storage Optionally, you can pass the StorageForDebugOverlayDrawTime instance here, to avoid looking it up repeatedly.
 */

function isDebugOverlay(component) {
  var storage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : useRootEntity().getComponent(StorageForDebugOverlayDrawTime) || useNewRootComponent(StorageForDebugOverlayDrawTime);
  if (!storage) return false;
  return storage.componentsWithDebugOverlayDrawTime.has(component);
}
/** The default draw order. If you are implementing a custom draw order, you may want to call this as your starting point. */


var defaultSort = function defaultSort(entities) {
  var nonDebugOverlayComponents = [];
  var debugOverlayComponents = [];
  var storageForIsDebugOverlay = useRootEntity().getComponent(StorageForDebugOverlayDrawTime); // Draw all entities, sorted by id (so that later-created entities are drawn above earlier-created entities)

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _toConsumableArray(entities).sort(function (entA, entB) {
      return entA.id - entB.id;
    })[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var ent = _step.value;

      var myDebugOverlayComponents = _toConsumableArray(ent.components).filter(function (component) {
        return isDebugOverlay(component, storageForIsDebugOverlay);
      });

      var myNonDebugOverlayComponents = _toConsumableArray(ent.components).filter(function (comp) {
        return !isDebugOverlay(comp, storageForIsDebugOverlay);
      });

      debugOverlayComponents = debugOverlayComponents.concat(myDebugOverlayComponents);
      nonDebugOverlayComponents = nonDebugOverlayComponents.concat(myNonDebugOverlayComponents);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return [].concat(_toConsumableArray(nonDebugOverlayComponents), _toConsumableArray(debugOverlayComponents));
};
/**
 * This Component can be placed on the root Entity to specify the draw order that the
 * `DrawChildren` Component will use. If no `Canvas.DrawOrder` Component is present on the
 * root Entity, then `Canvas.DrawOrder.defaultSort` will be used as the sort order.
 */


function DrawOrder(sort) {
  useType(DrawOrder);
  return {
    sort: sort
  };
}
/**
 * This component will check the root Entity for a Canvas.DrawOrder component, and
 * if it is present, it will return its `sort` function. Otherwise, it returns `Canvas.DrawOrder.defaultSort`.
 */


export function useCanvasDrawOrderSort() {
  var drawOrder = useRootEntity().getComponent(DrawOrder);
  return (drawOrder === null || drawOrder === void 0 ? void 0 : drawOrder.sort) || defaultSort;
}
/**
 * This Component can be placed on the root Entity to specify the draw order that the
 * `DrawChildren` Component will use. If no `Canvas.DrawOrder` Component is present on the
 * root Entity, then `Canvas.DrawOrder.defaultSort` will be used as the sort order.
 */

export default Object.assign(DrawOrder, {
  defaultSort: defaultSort,
  isDebugOverlay: isDebugOverlay
});