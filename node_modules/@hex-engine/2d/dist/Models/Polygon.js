function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import Vector from "./Vector";
/**
 * Represents a closed shape consisting of a set of connected straight line segments.
 */

var Polygon =
/*#__PURE__*/
function () {
  _createClass(Polygon, [{
    key: "points",

    /**
     * Points representing the corners where the polygon's line segments meet.
     * Their `x` and `y` properties refer to their position relative to the
     * polygon's [centroid](https://en.wikipedia.org/wiki/Centroid).
     *
     * The points are ordered such that one could draw the polygon by
     * placing a pen down at the first point, then dragging the pen in a straight line
     * to the second point, then the third, and so on until the last point,
     * which is connected to the first point.
     * */
    get: function get() {
      return this._points;
    },
    set: function set(newPoints) {
      Polygon._init(this, newPoints);
    }
  }, {
    key: "width",

    /**
     * The horizontal distance between the leftmost point in the polygon and the rightmost point on the polygon.
     */
    get: function get() {
      return this._width;
    },
    set: function set(newWidth) {
      var _this = this;

      if (Number.isNaN(newWidth)) return;
      var newPoints = this.points.map(function (point) {
        return point.multiplyX(newWidth / _this.width);
      });

      Polygon._init(this, newPoints);
    }
  }, {
    key: "height",

    /**
     * The vertical distance between the highest point in the polygon and the lowest point on the polygon.
     */
    get: function get() {
      return this._height;
    },
    set: function set(newHeight) {
      var _this2 = this;

      if (Number.isNaN(newHeight)) return;
      var newPoints = this.points.map(function (point) {
        return point.multiplyY(newHeight / _this2.height);
      });

      Polygon._init(this, newPoints);
    }
    /**
     * @param points Points representing the corners where the polygon's line segments meet.
     *
     * The points are ordered such that one could draw the polygon by
     * placing a pen down at the first point, then dragging the pen in a straight line
     * to the second point, then the third, and so on until the last point,
     * which is connected to the first point.
     *
     * Note that the x and y values on the points on the created Polygon
     * may not be the same as the x and y values on the points you give here,
     * because the constructor calculates the centroid of the polygon and then
     * recenters all points around it.
     */

  }]);

  function Polygon(points) {
    _classCallCheck(this, Polygon);

    _defineProperty(this, "_points", void 0);

    _defineProperty(this, "_width", void 0);

    _defineProperty(this, "_height", void 0);

    Polygon._init(this, points);
  }

  _createClass(Polygon, [{
    key: "boundingRectangle",

    /**
     * Creates a rectangular polygon whose width and height match that of this polygon;
     * said in other words, returns the rectangle that this polygon could be perfectly
     * [inscribed](https://www.mathopenref.com/inscribed.html) in.
     */
    value: function boundingRectangle() {
      return Polygon.rectangle(this.width, this.height);
    }
    /**
     * Returns whether the given point falls inside the polygon.
     * @param point The point to check.
     */

  }, {
    key: "containsPoint",
    value: function containsPoint(point) {
      var x = point.x,
          y = point.y;
      var points = this.points;
      var inside = false;

      for (var i = 0, j = points.length - 1; i < points.length; j = i++) {
        var xi = points[i].x;
        var yi = points[i].y;
        var xj = points[j].x;
        var yj = points[j].y;
        var intersect = yi > y != yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
        if (intersect) inside = !inside;
      }

      return inside;
    }
    /**
     * Returns whether this polygon has the same point values as another.
     * @param other The other polygon to compare to.
     */

  }, {
    key: "equals",
    value: function equals(other) {
      return this.points.every(function (point, index) {
        var otherPoint = other.points[index];
        return otherPoint && point.equals(otherPoint);
      });
    }
    /**
     * Draws this polygon onto a canvas context, using the current stroke or fill style.
     * @param context The canvas context to draw onto.
     * @param strokeOrFill Whether to use `context.stroke` or `context.fill` to draw the polygon.
     */

  }, {
    key: "draw",
    value: function draw(context, strokeOrFill) {
      var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          _ref$x = _ref.x,
          x = _ref$x === void 0 ? 0 : _ref$x,
          _ref$y = _ref.y,
          y = _ref$y === void 0 ? 0 : _ref$y;

      if (this.points.length === 0) return;
      var xOffset = this.width / 2 + x;
      var yOffset = this.height / 2 + y;
      context.save();
      context.translate(xOffset, yOffset);
      context.beginPath();
      context.moveTo(this.points[0].x, this.points[0].y);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.points.slice(1)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var point = _step.value;
          context.lineTo(point.x, point.y);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      context.closePath();

      if (strokeOrFill === "stroke") {
        context.stroke();
      } else {
        context.fill();
      }

      context.restore();
    }
  }], [{
    key: "_init",
    value: function _init(target, points) {
      var centroid = points.reduce(function (prev, curr) {
        return prev.addMutate(curr);
      }, new Vector(0, 0)).divideMutate(points.length);
      target._points = points.map(function (point) {
        return centroid.subtract(point);
      });
      var minX = target.points.reduce(function (prev, point) {
        return Math.min(point.x, prev);
      }, 0);
      var maxX = target.points.reduce(function (prev, point) {
        return Math.max(point.x, prev);
      }, 0);
      target._width = maxX - minX;
      var minY = target.points.reduce(function (prev, point) {
        return Math.min(point.y, prev);
      }, 0);
      var maxY = target.points.reduce(function (prev, point) {
        return Math.max(point.y, prev);
      }, 0);
      target._height = maxY - minY;
    }
    /**
     * Creates a rectangular polygon; a 4-sided polygon where the angles between all sides are all Ï€/2 radians (90 degrees).
     * @param size A Vector whose `x` and `y` properties refer to the desired width and height of the new rectangle.
     */

  }, {
    key: "rectangle",
    value: function rectangle(widthOrSize, maybeHeight) {
      var width, height;

      if (typeof widthOrSize === "number" && typeof maybeHeight === "number") {
        width = widthOrSize;
        height = maybeHeight;
      } else {
        width = widthOrSize.x;
        height = widthOrSize.y;
      }

      return new Polygon([new Vector(0, 0), new Vector(width, 0), new Vector(width, height), new Vector(0, height)]);
    }
  }]);

  return Polygon;
}();

export { Polygon as default };