function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * A generic object with an `x` and `y` property.
 *
 * A two-dimensional vector, used to represent points, sizes, and more.
 */
var Vector =
/*#__PURE__*/
function () {
  _createClass(Vector, [{
    key: "magnitude",
    set: function set(newValue) {
      this.normalizeMutate();
      this.x *= newValue;
      this.y *= newValue;
    },
    get: function get() {
      return Math.sqrt(Math.pow(0 - this.x, 2) + Math.pow(0 - this.y, 2));
    }
  }, {
    key: "angle",
    get: function get() {
      // Invert y component because JS math functions
      // assume normal coordinate space
      var radians = Math.atan2(-this.y, this.x);
      return radians;
    },
    set: function set(newValue) {
      var x = this.magnitude * Math.cos(newValue);
      var y = -(this.magnitude * Math.sin(newValue)); // Inverted because of canvas coordinate space

      this.x = x;
      this.y = y;
    }
  }]);

  function Vector(x, y) {
    _classCallCheck(this, Vector);

    _defineProperty(this, "x", void 0);

    _defineProperty(this, "y", void 0);

    this.x = x;
    this.y = y;
  }
  /** Create a Vector from any object with an x property and a y property. */


  _createClass(Vector, [{
    key: "clone",

    /** Create a new Vector with the same x and y values as this one. */
    value: function clone() {
      return new Vector(this.x, this.y);
    }
    /** Create a new Vector whose x and y values have the opposite sign as this one's. */

  }, {
    key: "opposite",
    value: function opposite() {
      return new Vector(-this.x, -this.y);
    }
    /** Mutate this Vector so that its x and y values have the opposite sign. */

  }, {
    key: "oppositeMutate",
    value: function oppositeMutate() {
      this.x = -this.x;
      this.y = -this.y;
      return this;
    }
    /** Create a new Vector whose x and y values are equivalent to this one's, but with the specified value added. */

  }, {
    key: "add",
    value: function add(other) {
      if (typeof other === "number") {
        return new Vector(this.x + other, this.y + other);
      } else {
        return new Vector(this.x + other.x, this.y + other.y);
      }
    }
    /** Mutate this Vector by adding the specified value to its x and y values. */

  }, {
    key: "addMutate",
    value: function addMutate(other) {
      if (typeof other === "number") {
        this.x += other;
        this.y += other;
      } else {
        this.x += other.x;
        this.y += other.y;
      }

      return this;
    }
    /** Create a new Vector whose x and y values are equivalent to this one's, but with the specified value added to the x value. */

  }, {
    key: "addX",
    value: function addX(amount) {
      return new Vector(this.x + amount, this.y);
    }
    /** Mutate this Vector by adding the specified value to its x value. */

  }, {
    key: "addXMutate",
    value: function addXMutate(amount) {
      this.x += amount;
      return this;
    }
    /** Create a new Vector whose x and y values are equivalent to this one's, but with the specified value added to the y value. */

  }, {
    key: "addY",
    value: function addY(amount) {
      return new Vector(this.x, this.y + amount);
    }
    /** Mutate this Vector by adding the specified value to its y value. */

  }, {
    key: "addYMutate",
    value: function addYMutate(amount) {
      this.y += amount;
      return this;
    }
    /** Create a new Vector whose x and y values are equivalent to this one's, but with the specified value subtracted. */

  }, {
    key: "subtract",
    value: function subtract(other) {
      if (typeof other === "number") {
        return new Vector(this.x - other, this.y - other);
      } else {
        return new Vector(this.x - other.x, this.y - other.y);
      }
    }
    /** Mutate this Vector by subtracting the specified value from its x and y values. */

  }, {
    key: "subtractMutate",
    value: function subtractMutate(other) {
      if (typeof other === "number") {
        this.x -= other;
        this.y -= other;
      } else {
        this.x -= other.x;
        this.y -= other.y;
      }

      return this;
    }
    /** Create a new Vector whose x and y values are equivalent to this one's, but with the specified value subtracted from the x value. */

  }, {
    key: "subtractX",
    value: function subtractX(amount) {
      return new Vector(this.x - amount, this.y);
    }
    /** Mutate this Vector by subtracting the specified value from its x value. */

  }, {
    key: "subtractXMutate",
    value: function subtractXMutate(amount) {
      this.x -= amount;
      return this;
    }
    /** Create a new Vector whose x and y values are equivalent to this one's, but with the specified value subtracted from the y value. */

  }, {
    key: "subtractY",
    value: function subtractY(amount) {
      return new Vector(this.x, this.y - amount);
    }
    /** Mutate this Vector by subtracting the specified value from its y value. */

  }, {
    key: "subtractYMutate",
    value: function subtractYMutate(amount) {
      this.y -= amount;
      return this;
    }
    /** Create a new Vector whose x and y values are equivalent to this one's, but with each multiplied by the specified value. */

  }, {
    key: "multiply",
    value: function multiply(other) {
      if (typeof other === "number") {
        return new Vector(this.x * other, this.y * other);
      } else {
        return new Vector(this.x * other.x, this.y * other.y);
      }
    }
    /** Mutate this Vector by multiplying its x and y values with the specified value. */

  }, {
    key: "multiplyMutate",
    value: function multiplyMutate(other) {
      if (typeof other === "number") {
        this.x *= other;
        this.y *= other;
      } else {
        this.x *= other.x;
        this.y *= other.y;
      }

      return this;
    }
    /** Create a new Vector whose x and y values are equivalent to this one's, but with the x value multiplied by the specified value. */

  }, {
    key: "multiplyX",
    value: function multiplyX(amount) {
      return new Vector(this.x * amount, this.y);
    }
    /** Mutate this Vector by multiplying its x value by the specified value. */

  }, {
    key: "multiplyXMutate",
    value: function multiplyXMutate(amount) {
      this.x *= amount;
      return this;
    }
    /** Create a new Vector whose x and y values are equivalent to this one's, but with the y value multiplied by the specified value. */

  }, {
    key: "multiplyY",
    value: function multiplyY(amount) {
      return new Vector(this.x, this.y * amount);
    }
    /** Mutate this Vector by multiplying its y value by the specified value. */

  }, {
    key: "multiplyYMutate",
    value: function multiplyYMutate(amount) {
      this.y *= amount;
      return this;
    }
    /** Create a new Vector whose x and y values are equivalent to this one's, but with each divided by the specified value. */

  }, {
    key: "divide",
    value: function divide(other) {
      if (typeof other === "number") {
        return new Vector(this.x / other, this.y / other);
      } else {
        return new Vector(this.x / other.x, this.y / other.y);
      }
    }
    /** Mutate this Vector by dividing its x and y values by the specified value. */

  }, {
    key: "divideMutate",
    value: function divideMutate(other) {
      if (typeof other === "number") {
        this.x /= other;
        this.y /= other;
      } else {
        this.x /= other.x;
        this.y /= other.y;
      }

      return this;
    }
    /** Create a new Vector whose x and y values are equivalent to this one's, but with its x value divided by the specified value. */

  }, {
    key: "divideX",
    value: function divideX(amount) {
      return new Vector(this.x / amount, this.y);
    }
    /** Mutate this Vector by dividing its x value by the specified value. */

  }, {
    key: "divideXMutate",
    value: function divideXMutate(amount) {
      this.x /= amount;
      return this;
    }
    /** Create a new Vector whose x and y values are equivalent to this one's, but with its y value divided by the specified value. */

  }, {
    key: "divideY",
    value: function divideY(amount) {
      return new Vector(this.x, this.y / amount);
    }
    /** Mutate this Vector by dividing its y value by the specified value. */

  }, {
    key: "divideYMutate",
    value: function divideYMutate(amount) {
      this.y /= amount;
      return this;
    }
    /** Check if this Vector and another Vector have the same x and y values. */

  }, {
    key: "equals",
    value: function equals(other) {
      return this.x === other.x && this.y === other.y;
    }
    /** Measure the distance between this Vector and another Vector. */

  }, {
    key: "distanceTo",
    value: function distanceTo(other) {
      return Math.sqrt(Math.pow(other.x - this.x, 2) + Math.pow(other.y - this.y, 2));
    }
    /** Return a new Vector that is the same as this Vector, but with its x and y values rounded to the nearest integer. */

  }, {
    key: "round",
    value: function round() {
      return new Vector(Math.round(this.x), Math.round(this.y));
    }
    /** Mutate this Vector by rounding its x and y values to the nearest integer. */

  }, {
    key: "roundMutate",
    value: function roundMutate() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      return this;
    }
    /** Return a new Vector that is the same as this Vector, but with its x and y values rounded down to the nearest integer. */

  }, {
    key: "roundDown",
    value: function roundDown() {
      return new Vector(Math.floor(this.x), Math.floor(this.y));
    }
    /** Mutate this Vector by rounding its x and y values down to the nearest integer. */

  }, {
    key: "roundDownMutate",
    value: function roundDownMutate() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      return this;
    }
    /** Return a new Vector that is the same as this Vector, but with its x and y values rounded up to the nearest integer. */

  }, {
    key: "roundUp",
    value: function roundUp() {
      return new Vector(Math.ceil(this.x), Math.ceil(this.y));
    }
    /** Mutate this Vector by rounding its x and y values up to the nearest integer. */

  }, {
    key: "roundUpMutate",
    value: function roundUpMutate() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      return this;
    }
    /** Mutate this Vector by setting its x and y values to the values found on the provided object. */

  }, {
    key: "mutateInto",
    value: function mutateInto(other) {
      this.x = other.x;
      this.y = other.y;
    }
    /** Create a new Vector by normalizing the magnitude of this one. */

  }, {
    key: "normalize",
    value: function normalize() {
      var existingMagnitude = this.magnitude;
      var normalizedX = this.x / existingMagnitude;
      var normalizedY = this.y / existingMagnitude;
      return new Vector(normalizedX, normalizedY);
    }
    /** Mutate this point by normalizing its magnitude. */

  }, {
    key: "normalizeMutate",
    value: function normalizeMutate() {
      var existingMagnitude = this.magnitude;
      var normalizedX = this.x / existingMagnitude;
      var normalizedY = this.y / existingMagnitude;
      this.x = normalizedX;
      this.y = normalizedY;
      return this;
    }
    /** Create a new Vector equivalent to this one but rotated by the specified amount (in radians), clockwise. */

  }, {
    key: "rotate",
    value: function rotate(radians) {
      var nextPoint = this.clone();
      nextPoint.angle += radians;
      return nextPoint;
    }
    /** Mutate this Vector by rotating it the specified amount (in radians), clockwise. */

  }, {
    key: "rotateMutate",
    value: function rotateMutate(radians) {
      this.angle += radians;
      return this;
    }
    /** Return the dot product with the other vector. If it's negative, they are in opposite directions */

  }, {
    key: "dotProduct",
    value: function dotProduct(other) {
      return other.x * this.x + other.y * this.y;
    }
    /** Return a vector perpendicular to this one with the same magnitude */

  }, {
    key: "perpendicular",
    value: function perpendicular() {
      // Rotates clockwise, assuming y points down
      return new Vector(-this.y, this.x);
    }
    /** Rotates this vector to become perpendicular to its former self */

  }, {
    key: "perpendicularMutate",
    value: function perpendicularMutate() {
      // Rotates clockwise, assuming y points down
      var _ref = [-this.y, this.x];
      this.x = _ref[0];
      this.y = _ref[1];
      return this;
    }
    /** Create a DOMPoint with the same x and y values as this Vector. */

  }, {
    key: "asDOMPoint",
    value: function asDOMPoint() {
      if (window.DOMPoint) {
        return new DOMPoint(this.x, this.y);
      }

      var g = document.createElementNS("http://www.w3.org/2000/svg", "g");

      if (typeof g.createSVGPoint === "function") {
        var point = g.createSVGPoint();
        point.x = this.x;
        point.y = this.y;
        return point;
      } else {
        throw new Error("Unable to convert Vector to DOMPoint in this browser");
      }
    }
    /** Create a new Vector by transforming this Vector using the provided DOMMatrix. */

  }, {
    key: "transformUsingMatrix",
    value: function transformUsingMatrix(matrix) {
      var domPoint = this.asDOMPoint();
      var transformed = domPoint.matrixTransform(matrix);
      return new Vector(transformed.x, transformed.y);
    }
    /** Mutate this Vector by transforming its x and y values using the provided DOMMatrix. */

  }, {
    key: "transformUsingMatrixMutate",
    value: function transformUsingMatrixMutate(matrix) {
      var domPoint = this.asDOMPoint();
      var transformed = domPoint.matrixTransform(matrix);
      this.x = transformed.x;
      this.y = transformed.y;
      return this;
    }
  }], [{
    key: "from",
    value: function from(_ref2) {
      var x = _ref2.x,
          y = _ref2.y;
      return new Vector(x, y);
    }
    /** Create a Vector from an angle and magnitude. */

  }, {
    key: "fromAngleAndMagnitude",
    value: function fromAngleAndMagnitude(angle, magnitude) {
      var point = new Vector(1, 1);
      point.angle = angle;
      point.magnitude = magnitude;
      return point;
    }
  }]);

  return Vector;
}();

export { Vector as default };