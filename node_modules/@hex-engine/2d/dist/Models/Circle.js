function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import Vector from "./Vector";
import Polygon from "./Polygon";
var origin = new Vector(0, 0);
/**
 * Represents a circle; a shape with infinite points along its edge that are all
 * equidistant from its center.
 *
 * The distance between the center and the edge points is known as the circle's
 * radius.
 */

var Circle =
/*#__PURE__*/
function () {
  _createClass(Circle, [{
    key: "diameter",

    /**
     * The radius of this circle; the length of a line segment that starts at the
     * circle's center and goes to its edge.
     */

    /**
     * The diameter of this circle; the length of a line segment that starts at
     * the circle's edge, crosses through the circle's center, and continues to
     * the opposite edge.
     */
    get: function get() {
      return this.radius * 2;
    },
    set: function set(newValue) {
      this.radius = newValue * 2;
    }
    /**
     * The width of this circle; same as the diameter.
     */

  }, {
    key: "width",
    get: function get() {
      return this.radius * 2;
    },
    set: function set(newValue) {
      this.radius = newValue * 2;
    }
    /**
     * The height of this circle; same as the diameter.
     */

  }, {
    key: "height",
    get: function get() {
      return this.radius * 2;
    },
    set: function set(newValue) {
      this.radius = newValue * 2;
    }
  }]);

  function Circle(radius) {
    _classCallCheck(this, Circle);

    _defineProperty(this, "radius", void 0);

    this.radius = radius;
  }
  /**
   * Creates a rectangular polygon whose width and height are double this circle's radius;
   * said in other words, returns the rectangle that this circle could be perfectly
   * [inscribed](https://www.mathopenref.com/inscribed.html) in.
   */


  _createClass(Circle, [{
    key: "boundingRectangle",
    value: function boundingRectangle() {
      return Polygon.rectangle(this.width, this.height);
    }
    /**
     * Returns a value indicating if a given point is either within the circle or on the its edge.
     * @param point The point to check.
     */

  }, {
    key: "containsPoint",
    value: function containsPoint(point) {
      var distance = point.distanceTo(origin);
      return distance <= this.radius;
    }
    /**
     * Returns whether this circle has the same radius as another.
     * @param other The other circle to compare to.
     */

  }, {
    key: "equals",
    value: function equals(other) {
      return this.radius === other.radius;
    }
    /**
     * Draws this circle onto a canvas context, using the current stroke or fill style.
     * @param context The canvas context to draw onto.
     * @param strokeOrFill Whether to use `context.stroke` or `context.fill` to draw the circle.
     */

  }, {
    key: "draw",
    value: function draw(context, strokeOrFill) {
      var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          _ref$x = _ref.x,
          x = _ref$x === void 0 ? 0 : _ref$x,
          _ref$y = _ref.y,
          y = _ref$y === void 0 ? 0 : _ref$y;

      var xOffset = this.width / 2 + x;
      var yOffset = this.height / 2 + y;
      context.beginPath();
      context.arc(xOffset, yOffset, this.radius, 0, 2 * Math.PI);

      if (strokeOrFill === "stroke") {
        context.stroke();
      } else {
        context.fill();
      }

      context.closePath();
    }
  }]);

  return Circle;
}();

export { Circle as default };