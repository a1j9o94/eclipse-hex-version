function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import Vector from "./Vector";
export function createSVGMatrix() {
  var matrix = window.DOMMatrix ? new DOMMatrix() : document.createElementNS("http://www.w3.org/2000/svg", "g").getCTM();

  if (matrix == null) {
    throw new Error("Unable to create transformation matrix. Maybe try using a newer browser?");
  }

  return matrix;
}
/** Represents a 2-dimensional transformation matrix. */

var TransformMatrix =
/*#__PURE__*/
function () {
  _createClass(TransformMatrix, null, [{
    key: "fromDOMMatrix",

    /** Create a TransformMatrix from a DOMMatrix of SVGMatrix. */
    value: function fromDOMMatrix(domMatrix) {
      var a = domMatrix.a,
          b = domMatrix.b,
          c = domMatrix.c,
          d = domMatrix.d,
          e = domMatrix.e,
          f = domMatrix.f;
      return new TransformMatrix(a, b, c, d, e, f);
    }
  }]);

  function TransformMatrix() {
    _classCallCheck(this, TransformMatrix);

    _defineProperty(this, "_matrix", void 0);

    this._matrix = createSVGMatrix();

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (args.length === 6) {
      var _a = args[0],
          _b = args[1],
          _c = args[2],
          _d = args[3],
          _e = args[4],
          _f = args[5];
      Object.assign(this._matrix, {
        a: _a,
        b: _b,
        c: _c,
        d: _d,
        e: _e,
        f: _f
      });
    }
  }
  /** Creates a new TransformMatrix with the same values as this one, but with a scale operation applied. */


  _createClass(TransformMatrix, [{
    key: "scale",
    value: function scale() {
      var sizeX, sizeY, originX, originY;

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      if (args.length === 2) {
        sizeX = args[0].x;
        sizeY = args[0].y;
        originX = args[1].x;
        originY = args[1].y;
      } else {
        sizeX = args[0];
        sizeY = args[1];
        originX = args[2];
        originY = args[3];
      }

      return TransformMatrix.fromDOMMatrix(this._matrix.scale(sizeX, sizeY, undefined, originX, originY, undefined));
    }
    /** Mutates this TransformMatrix by applying a scale operation. */

  }, {
    key: "scaleMutate",
    value: function scaleMutate() {
      var sizeX, sizeY, originX, originY;

      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      if (args.length === 2) {
        sizeX = args[0].x;
        sizeY = args[0].y;
        originX = args[1].x;
        originY = args[1].y;
      } else {
        sizeX = args[0];
        sizeY = args[1];
        originX = args[2];
        originY = args[3];
      }

      if (typeof this._matrix.scaleSelf === "function") {
        this._matrix.scaleSelf(sizeX, sizeY, undefined, originX, originY, undefined);
      } else {
        this._matrix = this._matrix.scale(sizeX, sizeY, undefined, originX, originY, undefined);
      }

      return this;
    }
    /** Creates a new TransformMatrix with the same values as this one, but with a translation applied. */

  }, {
    key: "translate",
    value: function translate(posOrX, maybeY) {
      var x, y;

      if (typeof posOrX === "number") {
        x = posOrX;
        y = maybeY;
      } else {
        x = posOrX.x;
        y = posOrX.y;
      }

      return TransformMatrix.fromDOMMatrix(this._matrix.translate(x, y));
    }
    /** Mutates this TransformMatrix by applying a translation. */

  }, {
    key: "translateMutate",
    value: function translateMutate(posOrX, maybeY) {
      var x, y;

      if (typeof posOrX === "number") {
        x = posOrX;
        y = maybeY;
      } else {
        x = posOrX.x;
        y = posOrX.y;
      }

      if (typeof this._matrix.translateSelf === "function") {
        this._matrix.translateSelf(x, y);
      } else {
        this._matrix = this._matrix.translate(x, y);
      }

      return this;
    }
    /** Creates a new TransformMatrix with the same values as this one, but with a rotation applied. */

  }, {
    key: "rotate",
    value: function rotate(radians) {
      // canvas `rotate` uses radians, DOMMatrix uses degrees.
      var degrees = radians * 180 / Math.PI;
      return TransformMatrix.fromDOMMatrix(this._matrix.rotate(degrees));
    }
    /** Mutates this TransformMatrix by applying a rotation. */

  }, {
    key: "rotateMutate",
    value: function rotateMutate(radians) {
      // canvas `rotate` uses radians, DOMMatrix uses degrees.
      var degrees = radians * 180 / Math.PI;

      if (typeof this._matrix.rotateSelf === "function") {
        this._matrix.rotateSelf(degrees);
      } else {
        this._matrix = this._matrix.rotate(degrees);
      }

      return this;
    }
    /** Creates a new TransformMatrix by multiplying this one with another. */

  }, {
    key: "multiply",
    value: function multiply(other) {
      var otherDomMatrix = other instanceof TransformMatrix ? other._matrix : other;
      return TransformMatrix.fromDOMMatrix(this._matrix.multiply(otherDomMatrix));
    }
    /** Mutates this TransformMatrix by multiplying it with another. */

  }, {
    key: "multiplyMutate",
    value: function multiplyMutate(other) {
      var otherDomMatrix = other instanceof TransformMatrix ? other._matrix : other;

      if (typeof this._matrix.multiplySelf === "function") {
        this._matrix.multiplySelf(otherDomMatrix);
      } else {
        this._matrix = this._matrix.multiply(otherDomMatrix);
      }

      return this;
    }
    /**
     * Applies this TransformMatrix's transform to the provided Vector values, and returns a new Vector.
     *
     * This does *not* mutate the provided Vector.
     */

  }, {
    key: "transformPoint",
    value: function transformPoint(point) {
      var domPoint = point.asDOMPoint().matrixTransform(this._matrix);
      return new Vector(domPoint.x, domPoint.y);
    }
    /**
     * Applies this TransformMatrix's transform to the provided Vector values, and mutates the provided Vector to contain the transformed values.
     */

  }, {
    key: "transformPointMutate",
    value: function transformPointMutate(point) {
      var domPoint = point.asDOMPoint().matrixTransform(this._matrix);
      point.mutateInto(domPoint);
      return point;
    }
    /** Return a new TransformMatrix that applies the inverse transformation as this one. */

  }, {
    key: "inverse",
    value: function inverse() {
      return TransformMatrix.fromDOMMatrix(this._matrix.inverse());
    }
    /** Mutate this TransformMatrix by inverting its transformation. */

  }, {
    key: "inverseMutate",
    value: function inverseMutate() {
      if (typeof this._matrix.invertSelf === "function") {
        this._matrix.invertSelf();
      } else {
        this._matrix = this._matrix.inverse();
      }

      return this;
    }
    /**
     * Returns the `a` component of this TransformMatrix, where this TransformMatrix's components can be represented as follows:
     *
     * ```
     * [ a c e
     *   b d f
     *   0 0 1 ]
     * ```
     *
     * The `a` component affects horizontal scaling. A value of 1 results in no scaling.
     */

  }, {
    key: "a",
    get: function get() {
      return this._matrix.a;
    },
    set: function set(newValue) {
      this._matrix.a = newValue;
    }
    /**
     * Returns the `b` component of this TransformMatrix, where this TransformMatrix's components can be represented as follows:
     *
     * ```
     * [ a c e
     *   b d f
     *   0 0 1 ]
     * ```
     *
     * The `b` component affects vertical skewing.
     */

  }, {
    key: "b",
    get: function get() {
      return this._matrix.b;
    },
    set: function set(newValue) {
      this._matrix.b = newValue;
    }
    /**
     * Returns the `c` component of this TransformMatrix, where this TransformMatrix's components can be represented as follows:
     *
     * ```
     * [ a c e
     *   b d f
     *   0 0 1 ]
     * ```
     *
     * The `c` component affects horizontal skewing.
     */

  }, {
    key: "c",
    get: function get() {
      return this._matrix.c;
    },
    set: function set(newValue) {
      this._matrix.c = newValue;
    }
    /**
     * Returns the `d` component of this TransformMatrix, where this TransformMatrix's components can be represented as follows:
     *
     * ```
     * [ a c e
     *   b d f
     *   0 0 1 ]
     * ```
     *
     * The `d` component affects vertical scaling. A value of 1 results in no scaling.
     */

  }, {
    key: "d",
    get: function get() {
      return this._matrix.d;
    },
    set: function set(newValue) {
      this._matrix.d = newValue;
    }
    /**
     * Returns the `e` component of this TransformMatrix, where this TransformMatrix's components can be represented as follows:
     *
     * ```
     * [ a c e
     *   b d f
     *   0 0 1 ]
     * ```
     *
     * The `e` component affects horizontal translation (movement).
     */

  }, {
    key: "e",
    get: function get() {
      return this._matrix.e;
    },
    set: function set(newValue) {
      this._matrix.e = newValue;
    }
    /**
     * Returns the `f` component of this TransformMatrix, where this TransformMatrix's components can be represented as follows:
     *
     * ```
     * [ a c e
     *   b d f
     *   0 0 1 ]
     * ```
     *
     * The `f` component affects vertical translation (movement).
     */

  }, {
    key: "f",
    get: function get() {
      return this._matrix.f;
    },
    set: function set(newValue) {
      this._matrix.f = newValue;
    }
  }]);

  return TransformMatrix;
}();

export { TransformMatrix as default };