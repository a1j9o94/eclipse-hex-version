function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

import { useType, useRootEntity, useNewRootComponent } from "@hex-engine/core";
import Canvas, { useCanvasDrawOrderSort } from "../Canvas";
import { Geometry } from "../Components";
import useEntityTransforms from "./useEntityTransforms";
import useUpdate from "./useUpdate";
/**
 * Caches the result of useEntitiesAtPoint each frame, for the duration of
 * that frame, so that we don't have to calculate the result of useEntitiesAtPoint
 * every frame. This saves a lot of runtime when there are many entities onscreen.
 */

function CacheForUseEntitiesAtPoint() {
  useType(CacheForUseEntitiesAtPoint);
  var result = {
    valid: false,
    ents: []
  };
  useUpdate(function () {
    // Invalidate cache every frame
    result.valid = false;
  });
  return {
    result: result
  };
}
/**
 * Get all the entities at the given world position,
 * sorted by reverse draw order, such that one that
 * gets drawn last (and is therefore on top) is the first in the array.
 */


export default function useEntitiesAtPoint(worldPos) {
  var rootEnt = useRootEntity();
  var cache = rootEnt.getComponent(CacheForUseEntitiesAtPoint) || useNewRootComponent(CacheForUseEntitiesAtPoint);

  if (cache.result.valid) {
    return cache.result.ents;
  }

  var rootsDescendants = rootEnt.descendants();
  var allEnts = [rootEnt].concat(_toConsumableArray(rootsDescendants));
  var entsUnderCursor = allEnts.filter(function (ent) {
    var geometry = ent.getComponent(Geometry);
    if (!geometry) return false;
    var transformedPos = useEntityTransforms(ent).matrixForWorldPosition().inverseMutate().transformPoint(worldPos);
    return geometry.shape.containsPoint(transformedPos);
  });

  if (entsUnderCursor.length < 2) {
    cache.result.ents = entsUnderCursor;
    cache.result.valid = true;
    return entsUnderCursor;
  }

  var sort = useCanvasDrawOrderSort();
  var components = sort(entsUnderCursor).filter(function (comp) {
    return Canvas.DrawOrder.isDebugOverlay(comp);
  }).reverse();
  var entsSeenSoFar = new Set();
  var sortedEnts = [];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = components[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var component = _step.value;
      var ent = component.entity;

      if (!entsSeenSoFar.has(component.entity)) {
        entsSeenSoFar.add(ent);
        sortedEnts.push(ent);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  cache.result.ents = sortedEnts;
  cache.result.valid = true;
  return sortedEnts;
}