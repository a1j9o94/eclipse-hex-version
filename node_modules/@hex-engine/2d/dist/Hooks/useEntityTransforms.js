import { useCallbackAsCurrent, useEntity } from "@hex-engine/core";
import { Vector, TransformMatrix } from "../Models";
import { Geometry } from "../Components";

function getEntityTransformMatrix(entity, includeOrigin) {
  var matrix = new TransformMatrix();
  var geometry = entity.getComponent(Geometry);

  if (!geometry) {
    return matrix;
  }

  matrix.translateMutate(geometry.position);

  if (includeOrigin) {
    matrix.translateMutate(geometry.origin);
  }

  matrix.rotateMutate(geometry.rotation);
  matrix.scaleMutate(geometry.scale, new Vector(0, 0));
  return matrix;
}

function getEntityTransformMatrixForContext(entity, includeOrigin, roundToNearestPixel) {
  var matrix = new TransformMatrix();
  var geometry = entity.getComponent(Geometry);

  if (!geometry) {
    return matrix;
  }

  matrix.translateMutate(geometry.position);
  matrix.rotateMutate(geometry.rotation); // It's easier to draw things from the top-left, so move
  // the canvas there instead of to the center.

  if (includeOrigin) {
    // HACK: To avoid allocating a new vector, we mutate the origin and then mutate it right back.
    geometry.origin.oppositeMutate();
    matrix.translateMutate(geometry.origin);
    geometry.origin.oppositeMutate();
  }

  var topLeft = new Vector(geometry.shape.width / 2, geometry.shape.height / 2).oppositeMutate();
  matrix.translateMutate(topLeft);
  matrix.scaleMutate(geometry.scale, topLeft.opposite());

  if (roundToNearestPixel) {
    matrix.e = Math.round(matrix.e);
    matrix.f = Math.round(matrix.f);
  }

  return matrix;
}
/**
 * Get the matrix transforms for the specified Entity.
 * @param entity The entity to get the transforms for. If unspecified, this function will use the result of `useEntity()`.
 */


export default function useEntityTransforms() {
  var entity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : useEntity();
  var matrixForWorldPosition = useCallbackAsCurrent(function (getTransform) {
    var ancestors = entity.ancestors();
    var matrix = new TransformMatrix();
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = ancestors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var ancestor = _step.value;
        matrix.multiplyMutate(getTransform(ancestor, false));
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    matrix.multiplyMutate(getTransform(entity, true));
    return matrix;
  });
  return {
    /** Returns a transformation matrix that will turn a position relative to the Entity into a world position. */
    matrixForWorldPosition: matrixForWorldPosition.bind(null, getEntityTransformMatrix),

    /** Returns a transformation matrix that will turn a position relative to the Entity into a world position, relative to the Entity's top-left corner. */
    matrixForDrawPosition: useCallbackAsCurrent(function (roundToNearestPixel) {
      return matrixForWorldPosition(function (someEnt) {
        if (someEnt === entity) {
          return getEntityTransformMatrixForContext(someEnt, true, roundToNearestPixel);
        } else {
          return getEntityTransformMatrix(someEnt, false);
        }
      });
    })
  };
}