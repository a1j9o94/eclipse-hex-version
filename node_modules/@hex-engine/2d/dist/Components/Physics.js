function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

import { useType, useRootEntity, useDestroy, useEntity, useCallbackAsCurrent, useNewRootComponent } from "@hex-engine/core";
import Matter from "matter-js";
import { Vector } from "../Models";
import { useUpdate, useDraw, useDebugOverlayDrawTime } from "../Hooks"; // Matter needs this
// @ts-ignore

global.decomp = require("poly-decomp");

function name(name, fn) {
  Object.defineProperty(fn, "name", {
    value: name
  });
  return fn;
}

/**
 * A Component that should be placed on the root Entity if you want to use physics in your game.
 *
 * Hex Engine's Physics are provided by [Matter.js](https://brm.io/matter-js/).
 */
function PhysicsEngine() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$debugDraw = _ref.debugDraw,
      debugDraw = _ref$debugDraw === void 0 ? false : _ref$debugDraw,
      _ref$gravity = _ref.gravity,
      gravity = _ref$gravity === void 0 ? new Vector(0, 1) : _ref$gravity,
      _ref$enableSleeping = _ref.enableSleeping,
      enableSleeping = _ref$enableSleeping === void 0 ? true : _ref$enableSleeping;

  useType(PhysicsEngine);
  var engine = Matter.Engine.create(undefined, {
    enableSleeping: enableSleeping
  });
  engine.world.gravity.x = gravity.x;
  engine.world.gravity.y = gravity.y;
  var collisionListeners = new WeakMap();

  function addCollisionListener(callback) {
    var entity = useEntity();
    collisionListeners.set(entity, useCallbackAsCurrent(callback));
  }

  var toProcess = [];
  Matter.Events.on(engine, "collisionStart", function (event) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = event.pairs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var pair = _step.value;
        toProcess.push({
          kind: "start",
          pair: pair
        });
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  });
  Matter.Events.on(engine, "collisionEnd", function (event) {
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = event.pairs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var pair = _step2.value;
        toProcess.push({
          kind: "end",
          pair: pair
        });
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  });
  useUpdate(function () {
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = toProcess[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var _step3$value = _step3.value,
            kind = _step3$value.kind,
            pair = _step3$value.pair;
        var bodyA = pair.bodyA,
            bodyB = pair.bodyB; // @ts-ignore

        var entA = bodyA.entity; // @ts-ignore

        var entB = bodyB.entity;

        if (entA && collisionListeners.has(entA)) {
          var listener = collisionListeners.get(entA);

          if (listener) {
            listener({
              kind: kind,
              body: bodyB,
              entity: entB || null
            });
          }
        }

        if (entB && collisionListeners.has(entB)) {
          var _listener = collisionListeners.get(entB);

          if (_listener) {
            _listener({
              kind: kind,
              body: bodyA,
              entity: entA || null
            });
          }
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
          _iterator3["return"]();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    toProcess = [];
  });
  var lastDelta = null;
  useUpdate(function (delta) {
    if (delta > 100) {
      // Don't freeze up the main thread by making the engine calculate a ton of iterations.
      Matter.Engine.update(engine, 16.66);
      return;
    }

    if (lastDelta != null) {
      Matter.Engine.update(engine, delta, delta / lastDelta);
    } else {
      Matter.Engine.update(engine, delta);
    }

    lastDelta = delta;
  });
  var state = {
    /** The Matter.js Engine object. */
    engine: engine,

    /**
     * Adds a collision listener for the current Entity.
     *
     * It will be called when another Entity's Physics.Body starts and stops colliding with this Entity's.
     */
    addCollisionListener: addCollisionListener,

    /**
     * Whether to render red wireframes of all physics bodies and constraints
     * into the canvas, for debugging purposes.
     */
    debugDraw: debugDraw
  };

  function drawComposite(context, composite) {
    composite.bodies.forEach(drawBody.bind(null, context));
    composite.constraints.forEach(drawConstraint.bind(null, context));
    composite.composites.forEach(drawComposite.bind(null, context));
  }

  function drawBody(context, body) {
    context.beginPath();
    body.vertices.forEach(function (vert, index) {
      if (index === 0) {
        context.moveTo(vert.x, vert.y);
      } else {
        context.lineTo(vert.x, vert.y);
      }
    });
    context.closePath();
    context.stroke();
  }

  function drawConstraint(context, constraint) {
    if (!constraint.bodyA || !constraint.bodyB) return;
    var pos1 = Matter.Vector.add(constraint.bodyA.position, constraint.pointA);
    var pos2 = Matter.Vector.add(constraint.bodyB.position, constraint.pointB);
    context.beginPath();
    context.moveTo(pos1.x, pos1.y);
    context.lineTo(pos2.x, pos2.y);
    context.stroke();
  }

  useDebugOverlayDrawTime();
  useDraw(function (context) {
    if (state.debugDraw) {
      context.strokeStyle = "red";
      context.lineWidth = 1;
      drawComposite(context, engine.world);
    }
  });
  return state;
}
/** Get the Physics Engine from the root Entity. If it is not present, throw an Error. */


function useEngine() {
  var _useRootEntity$getCom;

  var engine = ((_useRootEntity$getCom = useRootEntity().getComponent(PhysicsEngine)) === null || _useRootEntity$getCom === void 0 ? void 0 : _useRootEntity$getCom.engine) || useNewRootComponent(PhysicsEngine).engine;
  return engine;
}

function useCollisionListener() {
  var _useRootEntity$getCom2;

  var addCollisionListener = ((_useRootEntity$getCom2 = useRootEntity().getComponent(PhysicsEngine)) === null || _useRootEntity$getCom2 === void 0 ? void 0 : _useRootEntity$getCom2.addCollisionListener) || useNewRootComponent(PhysicsEngine).addCollisionListener;
  return addCollisionListener;
}
/**
 * A Component that should be added to any Entity that will participate in the physics simulation.
 *
 * Hex Engine's Physics are provided by [Matter.js](https://brm.io/matter-js/).
 */


function PhysicsBody(geometry) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$label = _ref2.label,
      label = _ref2$label === void 0 ? useEntity().name || undefined : _ref2$label,
      otherOpts = _objectWithoutProperties(_ref2, ["label"]);

  useType(PhysicsBody);

  if (geometry.origin.x !== 0 || geometry.origin.y !== 0) {
    throw new Error("Physics bodies only work with geometries whose origin is at 0, 0. You attempted to create a Physics Body using a geometry with origin ".concat(geometry.origin.x, ", ").concat(geometry.origin.y, "."));
  }

  var engine = useEngine();
  var addCollisionListener = useCollisionListener();

  var opts = _objectSpread({
    angle: geometry.rotation,
    label: label
  }, otherOpts);

  var body;
  var worldPos = geometry.worldPosition();

  if (geometry.shape.points) {
    var shape = geometry.shape;
    body = Matter.Bodies.fromVertices(worldPos.x, worldPos.y, [shape.points], opts);
  } else if (geometry.shape.radius != null) {
    var _shape = geometry.shape;
    body = Matter.Bodies.circle(worldPos.x, worldPos.y, _shape.radius, opts);
  } else {
    throw new Error("Unknown shape type; cannot construct physics body");
  } // @ts-ignore


  body.entity = useEntity();
  Matter.Composite.add(engine.world, body);
  useDestroy().onDestroy(function () {
    // @ts-ignore
    body.entity = null;
    Matter.World.remove(engine.world, body, true);
  });
  var lastPoints = geometry.shape.points;
  var lastRadius = geometry.shape.radius;
  useUpdate(function () {
    if (geometry.shape.points !== lastPoints) {
      var _shape2 = geometry.shape;

      var _worldPos = geometry.worldPosition();

      var nextBody = Matter.Bodies.fromVertices(_worldPos.x, _worldPos.y, [_shape2.points], _objectSpread({}, opts, {
        angle: geometry.rotation
      }));

      if (nextBody) {
        Matter.Body.setVertices(body, nextBody.vertices);
      }
    } else if (geometry.shape.radius != lastRadius) {
      var _shape3 = geometry.shape;

      var _worldPos2 = geometry.worldPosition();

      var _nextBody = Matter.Bodies.circle(_worldPos2.x, _worldPos2.y, _shape3.radius, opts);

      if (_nextBody) {
        Matter.Body.setVertices(body, _nextBody.vertices);
      }
    }

    if (body.isStatic) {
      Matter.Body.setPosition(body, geometry.position);
      Matter.Body.setAngle(body, geometry.rotation);
    } else {
      geometry.position.mutateInto(body.position);
      geometry.rotation = body.angle;
    }

    lastPoints = geometry.shape.points;
    lastRadius = geometry.shape.radius;
  });
  return {
    get body() {
      return body;
    },

    applyForce: function applyForce(position, force) {
      Matter.Body.applyForce(body, position, force);
    },
    setAngle: function setAngle(angle) {
      Matter.Body.setAngle(body, angle);
    },
    setAngularVelocity: function setAngularVelocity(velocity) {
      Matter.Body.setAngularVelocity(body, velocity);
    },
    setDensity: function setDensity(density) {
      Matter.Body.setDensity(body, density);
    },
    setInertia: function setInertia(inertia) {
      Matter.Body.setInertia(body, inertia);
    },
    setMass: function setMass(mass) {
      Matter.Body.setMass(body, mass);
    },
    setPosition: function setPosition(position) {
      Matter.Body.setPosition(body, position);
    },
    setStatic: function setStatic(isStatic) {
      Matter.Body.setStatic(body, isStatic);
    },
    setVelocity: function setVelocity(velocity) {
      Matter.Body.setVelocity(body, velocity);
    },
    onCollision: addCollisionListener
  };
}
/**
 * A Component that can be used to bind two physics bodies together with a rope,
 * spring, nail, or other real or imaginary constraint.
 *
 * Hex Engine's Physics are provided by [Matter.js](https://brm.io/matter-js/).
 */


function PhysicsConstraint(options) {
  useType(PhysicsConstraint);
  var engine = useEngine();
  var constraint = Matter.Constraint.create(options);
  Matter.World.add(engine.world, constraint);
  useDestroy().onDestroy(function () {
    Matter.World.remove(engine.world, constraint, true);
  });
  return {
    constraint: constraint
  };
}
/**
 * A Component that should be placed on the root Entity if you want to use physics in your game.
 *
 * Hex Engine's Physics are provided by [Matter.js](https://brm.io/matter-js/).
 */


export var Engine = name("Physics.Engine", PhysicsEngine);
/**
 * A Component that should be added to any Entity that will participate in the physics simulation.
 *
 * Hex Engine's Physics are provided by [Matter.js](https://brm.io/matter-js/).
 */

export var Body = name("Physics.Body", PhysicsBody);
/**
 * A Component that connects two Physics.Body Components together using a rope, spring, nail, etc.
 *
 * Hex Engine's Physics are provided by [Matter.js](https://brm.io/matter-js/).
 */

export var Constraint = name("Physics.Constraint", PhysicsConstraint);