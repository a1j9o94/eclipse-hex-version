function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { useType } from "@hex-engine/core";
import Preloader from "../Preloader";
var cache = {};

var Image =
/*#__PURE__*/
function () {
  function Image(config) {
    var _this = this;

    _classCallCheck(this, Image);

    _defineProperty(this, "url", void 0);

    _defineProperty(this, "_loadingPromise", null);

    _defineProperty(this, "loaded", false);

    _defineProperty(this, "data", null);

    _defineProperty(this, "_patterns", new Map());

    this.url = config.url;

    if (cache[config.url]) {
      return cache[config.url];
    }

    Preloader.addTask(function () {
      return _this.load();
    });
  }
  /**
   * Load this Image file. Note that Image files automatically start loading when they are created,
   * and no errors are thrown if you attempt to draw an Image file that hasn't loaded yet, so
   * in most cases, you do not need to call this function.
   */


  _createClass(Image, [{
    key: "load",
    value: function load() {
      var _this2 = this;

      if (this.loaded) return Promise.resolve();
      if (this._loadingPromise) return this._loadingPromise;
      this._loadingPromise = new Promise(function (resolve, reject) {
        var image = document.createElement("img");

        image.onload = function () {
          _this2.loaded = true;
          _this2.data = image;
          cache[_this2.url] = _this2;
          resolve();
        };

        image.onerror = function (event) {
          var error = new Error("Failed to load image"); // @ts-ignore

          error.event = event;
          reject(error);
        };

        image.src = _this2.url;
      }).then(function () {
        _this2._loadingPromise = null;
      });
      return this._loadingPromise;
    }
    /**
     * Creates a CanvasPattern for the Image, using the provided context.
     *
     * The primary use of a CanvasPattern is as a fillStyle or strokeStyle on a canvas context.
     *
     * @param context The context you're going to render onto.
     * @param repetition Whether to repeat the image, and along which axes. Valid values are "repeat", "repeat-x", "repeat-y", or "no-repeat". Defaults to "repeat", meaning repeat across both axes.
     * @param fallbackStyle A string, CanvasGradient, or CanvasPattern to use as a fallback if the image is not yet loaded, or if the pattern cannot be created. Defaults to "magenta".
     */

  }, {
    key: "asPattern",
    value: function asPattern(context) {
      var repetition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "repeat";
      var fallbackStyle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "magenta";

      if (this.loaded) {
        var _cache;

        if (this._patterns.has(repetition)) {
          _cache = this._patterns.get(repetition);
        } else {
          _cache = new WeakMap();

          this._patterns.set(repetition, _cache);
        }

        var maybeCached = _cache.get(context);

        if (maybeCached != null) return maybeCached;
        var result = context.createPattern(this.data, repetition);

        if (result == null) {
          return fallbackStyle;
        } else {
          _cache.set(context, result);

          return result;
        }
      } else {
        return fallbackStyle;
      }
    }
    /** Draw the Image into the provided canvas context, if it has been loaded. */

  }, {
    key: "draw",
    value: function draw(context, _ref) {
      var _ref2, _this$data, _ref3, _this$data2, _ref4, _this$data3, _ref5, _this$data4;

      var x = _ref.x,
          y = _ref.y,
          _ref$sourceX = _ref.sourceX,
          sourceX = _ref$sourceX === void 0 ? 0 : _ref$sourceX,
          _ref$sourceY = _ref.sourceY,
          sourceY = _ref$sourceY === void 0 ? 0 : _ref$sourceY,
          _ref$sourceWidth = _ref.sourceWidth,
          sourceWidth = _ref$sourceWidth === void 0 ? (_ref2 = (_this$data = this.data) === null || _this$data === void 0 ? void 0 : _this$data.width) !== null && _ref2 !== void 0 ? _ref2 : 100 : _ref$sourceWidth,
          _ref$sourceHeight = _ref.sourceHeight,
          sourceHeight = _ref$sourceHeight === void 0 ? (_ref3 = (_this$data2 = this.data) === null || _this$data2 === void 0 ? void 0 : _this$data2.height) !== null && _ref3 !== void 0 ? _ref3 : 100 : _ref$sourceHeight,
          _ref$targetWidth = _ref.targetWidth,
          targetWidth = _ref$targetWidth === void 0 ? (_ref4 = (_this$data3 = this.data) === null || _this$data3 === void 0 ? void 0 : _this$data3.width) !== null && _ref4 !== void 0 ? _ref4 : 100 : _ref$targetWidth,
          _ref$targetHeight = _ref.targetHeight,
          targetHeight = _ref$targetHeight === void 0 ? (_ref5 = (_this$data4 = this.data) === null || _this$data4 === void 0 ? void 0 : _this$data4.height) !== null && _ref5 !== void 0 ? _ref5 : 100 : _ref$targetHeight;
      var data = this.data;
      if (data == null) return;

      if (sourceWidth === 0 || sourceHeight === 0 || targetWidth === 0 || targetHeight === 0) {
        return;
      }

      context.drawImage(data, sourceX, sourceY, sourceWidth, sourceHeight, x, y, targetWidth, targetHeight);
    }
  }]);

  return Image;
}();
/**
 * A function that loads and draws an image from a URL.
 *
 * You can get a URL for an image on disk by `import`ing it, as if it was code:
 *
 * ```ts
 * import myImage from "./my-image.png";
 *
 * console.log(typeof myImage); // "string"
 *
 * useNewComponent(() => Image({ url: myImage }));
 * ```
 *
 * When you import an image in this way, it will be automatically
 * added to the build and included in the final build output.
 */


export default function ImageComponent(options) {
  useType(ImageComponent);
  return new Image(options);
}