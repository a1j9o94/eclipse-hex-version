function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

import { useType, useNewComponent, useChild, useEntityName, useCallbackAsCurrent } from "@hex-engine/core";
import Geometry from "./Geometry";
import Image from "./Image";
import SpriteSheet from "./SpriteSheet";
import TileMap from "./TileMap";
import { Grid, Vector, Polygon } from "../Models";
import { useDraw } from "../Hooks";
/**
 * The data that describes an entity inside of an Ogmo level.
 * This shape comes directly from the level json.
 */

/**
 * The default Ogmo decal component, used in the creation of decal entities
 * when rendering the decal layer of an ogmo level.
 *
 * It loads the image for the decal, and draws it with the position, rotation,
 * and scale specified by the decal data in the level.
 *
 * If you want to use a different component to render decals, instead of this
 * one, then you can override it when you create the Ogmo.Project by passing
 * a custom function as its `decalFactory` parameter.
 */
function Decal(_ref) {
  var geometryPromise = _ref.geometryPromise,
      image = _ref.image;
  useType(Decal);
  var loaded = false;
  geometryPromise.then(useCallbackAsCurrent(function (geomInit) {
    useNewComponent(function () {
      return Geometry(geomInit);
    });
    loaded = true;
  }));
  useDraw(function (context) {
    if (!loaded) return;
    image.draw(context, {
      x: 0,
      y: 0
    });
  });
}

Object.defineProperty(Decal, "name", {
  value: "Ogmo.Decal"
});

/**
 * A component that creates a TileMap component for a tile layer from
 * an Ogmo level.
 *
 * This component is used by Ogmo.TileRenderer which is the default
 * implementation for rendering tile layers from Ogmo levels. You may find
 * Ogmo.TileLayerParser useful if you are overriding the default TileRenderer
 * with a different implementation. To override it, pass a component function
 * to `useLevel` as its `tileRenderer` parameter.
 */
export function TileLayerParser(layer) {
  useType(TileLayerParser);
  var tileset = layer.projectLayer.defaultTileset;
  var spriteSheet = useNewComponent(function () {
    return SpriteSheet({
      url: tileset.path,
      tileWidth: tileset.tileSize.x,
      tileHeight: tileset.tileSize.y
    });
  });
  var tilemap = useNewComponent(function () {
    return TileMap(spriteSheet, layer.data);
  });
  return {
    tilemap: tilemap
  };
}
Object.defineProperty(TileLayerParser, "name", {
  value: "Ogmo.TileLayerParser"
});
/**
 * The default tile renderer implementation used when loading level data with
 * Ogmo.Project's useLevel method. You can pass an additional argument to
 * useLevel to use a different component. If you do, you may wish to use
 * Ogmo.TileLayerParser like this component does.
 */

export function TileRenderer(layer, _levelData) {
  useType(TileRenderer);

  var _useNewComponent = useNewComponent(function () {
    return TileLayerParser(layer);
  }),
      tilemap = _useNewComponent.tilemap;

  useDraw(function (context) {
    tilemap.draw(context);
  });
}
Object.defineProperty(TileRenderer, "name", {
  value: "Ogmo.TileRenderer"
});
/**
 * A component representing a single Ogmo level. When created, it will loop over all the
 * layers, decals, tiles, entities, and grids in the level, and create appropriate objects
 * to represent each.
 *
 * It cooperates with an Ogmo.Project component to get layer information and create entities
 * and decals.
 *
 * You cannot create these manually; instead, use the `useLevel` method on Ogmo.Project.
 */

function Level(project, levelData, tileRenderer) {
  useType(Level);

  var layers = _toConsumableArray(levelData.layers).reverse().map(function (layer, index) {
    var projectLayer = project.layers.find(function (projectLayer) {
      return projectLayer.exportID === layer._eid;
    });

    if (!projectLayer) {
      throw new Error("Ogmo level layer ".concat(index, " referenced non-existent project layer with exportID ").concat(layer._eid));
    }

    switch (projectLayer.definition) {
      case "tile":
        {
          var grid = new Grid(layer.gridCellsX, layer.gridCellsY, 0);
          grid.setData(layer.data);
          return {
            definition: "tile",
            projectLayer: projectLayer,
            data: grid
          };
        }

      case "grid":
        {
          var _grid = new Grid(layer.gridCellsX, layer.gridCellsY, "");

          _grid.setData(layer.grid);

          return {
            definition: "grid",
            projectLayer: projectLayer,
            grid: _grid
          };
        }

      case "entity":
        {
          return {
            definition: "entity",
            projectLayer: projectLayer,
            entities: layer.entities
          };
        }

      case "decal":
        {
          return {
            definition: "decal",
            projectLayer: projectLayer,
            decals: layer.decals
          };
        }
    }
  });

  var levelSizeInPixels = new Vector(levelData.width, levelData.height);
  layers.forEach(function (layer) {
    useChild(function () {
      useEntityName(layer.projectLayer.name);
      useNewComponent(function () {
        return Geometry({
          shape: Polygon.rectangle(levelSizeInPixels)
        });
      });

      switch (layer.definition) {
        case "tile":
          {
            useNewComponent(function () {
              return tileRenderer(layer, levelData);
            });
            break;
          }

        case "grid":
          {
            // Nothing to draw
            break;
          }

        case "entity":
          {
            layer.entities.forEach(function (entData) {
              project.createEntity(entData, levelSizeInPixels);
            });
            break;
          }

        case "decal":
          {
            layer.decals.forEach(function (decalData) {
              project.createDecal(decalData, levelSizeInPixels);
            });
          }
      }
    });
  });
  return {
    size: new Vector(levelData.width, levelData.height),
    offset: new Vector(levelData.offsetX, levelData.offsetY),
    values: levelData.values,
    layers: layers
  };
}

Object.defineProperty(Level, "name", {
  value: "Ogmo.Level"
});

function defaultDecalFactory(info) {
  return useChild(function () {
    return Decal(info);
  });
}
/**
 * The object passed to an entity factory function as passed into Ogmo.Project.
 *
 * Generally, all you'll do with this is pass it into the geometry constructor:
 * ```ts
 * // Given that `info` is an `Ogmo.EntityFactoryInfo`:
 * useNewComponent(() => Geometry(info));
 * ```
 *
 * However, if you use Ogmo's "custom values" feature, then you can find your values and their defaults in the `data` and `projectData` properties.
 *
 * @property `shape` - A `Shape` derived from the size of the entity in the level json or ogmo project, suitable for passing into the `Geometry` component.
 * @property `position` - A position `Vector` derived from the position of the entity in the level json, suitable for passing into the `Geometry` component.
 * @property `rotation` - The rotation (in radians) derived from the rotation of the entity in the level json, suitable for passing into the `Geometry` component.
 * @property `scale` - The X and Y scale components of derived from the scale of the entity in the level json, suitable for passing into the `Geometry` component.
 * @property `data` - The raw data object for this entity as found in the level json. Note that positions, rotations, sizes, and etc in this object are not normalized into Hex Engine's coordinate system.
 * @property `projectData` - The raw metadata object for this entity as found in the ogmo project. Note that positions, rotations, sizes, and etc in this object are not normalized into Hex Engine's coordinate system.
 */


/**
 * A Component that provides an interface for working with an [Ogmo Editor](https://ogmo-editor-3.github.io/) project.
 *
 * @param projectData The imported *.ogmo file
 * @param entityFactories An object map of functions that will be used to
 * construct entities in Ogmo levels, by name; for example: `{ player: (info) => useChild(() => Player(info)) }`. The type of the `info` parameter is a superset of the type required by the `Geometry` component, so you can pass it in directly to set up the entity's geometry.
 * @param decalFactory An optional function that will be called to construct entities for decals. The default implementation uses Ogmo.Decal.
 */
function Project(projectData) {
  var entityFactories = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var decalFactory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultDecalFactory;
  useType(Project);
  var project = {
    createEntity: function createEntity(entData, levelSizeInPixels) {
      var factoryForName = entityFactories[entData.name];

      if (factoryForName) {
        var _ref2, _entData$width, _entProjectData$size, _ref3, _entData$height, _entProjectData$size2, _entProjectData$origi, _entProjectData$origi2;

        var entProjectData = (projectData.entities || []).find(function (info) {
          return info.name === entData.name;
        });
        var size = new Vector((_ref2 = (_entData$width = entData.width) !== null && _entData$width !== void 0 ? _entData$width : entProjectData === null || entProjectData === void 0 ? void 0 : (_entProjectData$size = entProjectData.size) === null || _entProjectData$size === void 0 ? void 0 : _entProjectData$size.x) !== null && _ref2 !== void 0 ? _ref2 : 0, (_ref3 = (_entData$height = entData.height) !== null && _entData$height !== void 0 ? _entData$height : entProjectData === null || entProjectData === void 0 ? void 0 : (_entProjectData$size2 = entProjectData.size) === null || _entProjectData$size2 === void 0 ? void 0 : _entProjectData$size2.y) !== null && _ref3 !== void 0 ? _ref3 : 0);
        var position = new Vector(entData.x, entData.y).subtractMutate(levelSizeInPixels.divide(2)).addMutate(size.divide(2));

        if ((entProjectData === null || entProjectData === void 0 ? void 0 : entProjectData.origin) && (entProjectData === null || entProjectData === void 0 ? void 0 : (_entProjectData$origi = entProjectData.origin) === null || _entProjectData$origi === void 0 ? void 0 : _entProjectData$origi.x) && (entProjectData === null || entProjectData === void 0 ? void 0 : (_entProjectData$origi2 = entProjectData.origin) === null || _entProjectData$origi2 === void 0 ? void 0 : _entProjectData$origi2.y)) {
          position.subtractXMutate(entProjectData.origin.x);
          position.subtractYMutate(entProjectData.origin.y);
        } // Note: looks like at time of writing, entity rotation is always in degrees,
        // regardless of the angle export setting of the project


        var rotation = entData.rotation ? entData.rotation * (Math.PI / 180) : 0;
        var scale = new Vector(1, 1); // TODO

        return factoryForName({
          shape: Polygon.rectangle(size),
          // TODO support non-rectangle
          position: position,
          rotation: rotation,
          scale: scale,
          data: entData,
          projectData: entProjectData
        });
      } else {
        throw new Error("No Ogmo entity factory defined for: ".concat(entData.name));
      }
    },
    createDecal: function createDecal(decalData, levelSizeInPixels) {
      var image = useNewComponent(function () {
        return Image({
          url: decalData.texture
        });
      });
      var geometryPromise = image.load().then(function () {
        var _decalData$rotation, _decalData$scaleX, _decalData$scaleY;

        var data = image.data;

        if (!data) {
          return {
            shape: Polygon.rectangle(1, 1),
            position: new Vector(0, 0),
            rotation: 0,
            scale: new Vector(1, 1)
          };
        }

        var width = data.width,
            height = data.height;

        if (!width || !height) {
          return {
            shape: Polygon.rectangle(1, 1),
            position: new Vector(0, 0),
            rotation: 0,
            scale: new Vector(1, 1)
          };
        }

        var shape = Polygon.rectangle(width, height);
        var position = new Vector(decalData.x, decalData.y).subtractMutate(levelSizeInPixels.divide(2)); // Note: looks like at time of writing, decal rotation is always in radians,
        // regardless of the angle export setting of the project

        var rotation = (_decalData$rotation = decalData.rotation) !== null && _decalData$rotation !== void 0 ? _decalData$rotation : 0;
        var scale = new Vector((_decalData$scaleX = decalData.scaleX) !== null && _decalData$scaleX !== void 0 ? _decalData$scaleX : 1, (_decalData$scaleY = decalData.scaleY) !== null && _decalData$scaleY !== void 0 ? _decalData$scaleY : 1);
        return {
          shape: shape,
          position: position,
          rotation: rotation,
          scale: scale
        };
      });
      return decalFactory({
        geometryPromise: geometryPromise,
        image: image,
        data: decalData
      });
    },
    tilesets: [],
    layers: []
  };
  project.tilesets = projectData.tilesets.map(function (tileset) {
    return {
      label: tileset.label,
      path: tileset.path,
      tileSize: new Vector(tileset.tileWidth, tileset.tileHeight),
      tileSeparation: new Vector(tileset.tileSeparationX, tileset.tileSeparationY)
    };
  });
  project.layers = projectData.layers.map(function (layer, index) {
    switch (layer.definition) {
      case "tile":
        {
          var tileset = project.tilesets.find(function (tileset) {
            return tileset.label === layer.defaultTileset;
          });

          if (!tileset) {
            throw new Error("Ogmo layer ".concat(index, " referenced non-existent default tileset: '").concat(layer.defaultTileset, "'"));
          }

          return _objectSpread({}, layer, {
            gridSize: Vector.from(layer.gridSize),
            defaultTileset: tileset
          });
        }

      case "grid":
      case "entity":
      case "decal":
        {
          return _objectSpread({}, layer, {
            gridSize: Vector.from(layer.gridSize)
          });
        }
    }
  });
  return {
    /**
     * All of the tilesets specified in the Ogmo project.
     */
    tilesets: project.tilesets,

    /**
     * All of the layer definitions specified in the Ogmo project.
     */
    layers: project.layers,

    /**
     * Create a new OgmoLevel component for the given level data,
     * and add it to the current component's Entity.
     *
     * ```ts
     * import levelData from "./level.json";
     * ogmo.useLevel(levelData);
     * ```
     *
     * You may pass a component function as the second argument
     * to override the component used to render the level's tile
     * layers. By default, Ogmo.TileRenderer is used.
     */
    useLevel: function useLevel(levelData) {
      var tileRenderer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TileRenderer;
      return useNewComponent(function () {
        return Level(project, levelData, tileRenderer);
      });
    }
  };
}

Object.defineProperty(Project, "name", {
  value: "Ogmo.Project"
});
export { Project, Level, Decal };