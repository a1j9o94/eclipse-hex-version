function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { useType, useNewComponent } from "@hex-engine/core";
import Font from "./Font";
import FontMetrics from "./FontMetrics";
/** This Component uses an installed font on the system to render text into the canvas. */

export default function SystemFont(_ref) {
  var name = _ref.name,
      size = _ref.size,
      _ref$color = _ref.color,
      color = _ref$color === void 0 ? "black" : _ref$color;
  useType(SystemFont);
  var canvas = document.createElement("canvas");
  var internalContext = canvas.getContext("2d");
  var state = {
    name: name,
    size: size,
    color: color
  };
  state.size = size;

  function prepareContext(context) {
    context.font = "".concat(state.size, "px ").concat(state.name);
    context.fillStyle = state.color;
  }

  var baseApi = {
    readyToDraw: function readyToDraw() {
      return true;
    },
    drawText: function drawText(context, text) {
      var _options$x, _options$y;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      prepareContext(context);
      var oldBaseline = context.textBaseline;

      if (options.baseline) {
        context.textBaseline = options.baseline;
      }

      context.fillText(text, (_options$x = options.x) !== null && _options$x !== void 0 ? _options$x : 0, (_options$y = options.y) !== null && _options$y !== void 0 ? _options$y : 0);
      context.textBaseline = oldBaseline;
    },
    getFontSize: function getFontSize() {
      return state.size;
    },
    measureWidth: function measureWidth(text) {
      prepareContext(internalContext);
      var textMetrics = internalContext.measureText(text);
      return textMetrics.width;
    }
  };
  var fontMetrics = useNewComponent(function () {
    return FontMetrics(baseApi);
  });

  var fontApi = _objectSpread({}, baseApi, {
    measureText: fontMetrics.measureText
  });

  useNewComponent(function () {
    return Font(fontApi);
  });
  return _objectSpread({}, fontApi, {
    get name() {
      return state.name;
    },

    set name(nextValue) {
      state.name = nextValue;
    },

    get size() {
      return state.size;
    },

    set size(nextValue) {
      state.size = nextValue;
    },

    get color() {
      return state.color;
    },

    set color(nextValue) {
      state.color = nextValue;
    }

  });
}