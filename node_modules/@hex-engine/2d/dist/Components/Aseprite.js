import { useType, useNewComponent, useEnableDisable } from "@hex-engine/core";
import Animation, { AnimationFrame } from "./Animation";
import { Vector } from "../Models";
var LAYER_BLEND_MODES = {
  0: "Normal",
  1: "Multiply",
  2: "Screen",
  3: "Overlay",
  4: "Darken",
  5: "Lighten",
  6: "Color Dodge",
  7: "Color Burn",
  8: "Hard Light",
  9: "Soft Light",
  10: "Difference",
  11: "Exclusion",
  12: "Hue",
  13: "Saturation",
  14: "Color",
  15: "Luminosity",
  16: "Addition",
  17: "Subtract",
  18: "Divide"
};
var CANVAS_COMPOSITE_OPERATIONS_BY_BLEND_MODE = {
  0: "source-over",
  1: "multiply",
  2: "screen",
  3: "overlay",
  4: "darken",
  5: "lighten",
  6: "color-dodge",
  7: "color-burn",
  8: "hard-light",
  9: "soft-light",
  10: "difference",
  11: "exclusion",
  12: "hue",
  13: "saturation",
  14: "color",
  15: "luminosity" // There's no cooresponding globalCompositeOperation for these. We'd have to
  // implement them using getImageData/putImageData.
  // 16: "Addition",
  // 17: "Subtract",
  // 18: "Divide",

};
var frameCache = new WeakMap();
/** A Component which loads and draws Aseprites sprites and animations. */

export default function Aseprite(data) {
  useType(Aseprite);
  var maxW = data.frames.reduce(function (prevFrameVal, frame) {
    return Math.max(prevFrameVal, frame.cels.reduce(function (prevCelVal, cel) {
      return Math.max(prevCelVal, cel.w + cel.xpos);
    }, 0));
  }, 0);
  var maxH = data.frames.reduce(function (prevFrameVal, frame) {
    return Math.max(prevFrameVal, frame.cels.reduce(function (prevCelVal, cel) {
      return Math.max(prevCelVal, cel.h + cel.ypos);
    }, 0));
  }, 0);
  var size = new Vector(maxW, maxH);
  var animations = {};

  function colorAtPixel(cel, x, y) {
    if (data.colorDepth === 32) {
      // 32-bit color, one byte for each r, g, b, a
      var offset = 4 * (x + cel.w * y);
      var r = cel.rawCelData[offset + 0];
      var g = cel.rawCelData[offset + 1];
      var b = cel.rawCelData[offset + 2];
      var a = cel.rawCelData[offset + 3];
      return "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(a, ")");
    } else if (data.colorDepth === 8) {
      // indexed color. one byte for each pixel, referencing colors from palette
      var _offset = x + cel.w * y;

      var index = cel.rawCelData[_offset];

      if (!data.palette) {
        throw new Error("Invalid Aseprite file: Uses indexed color but there is no color palette");
      }

      var color = data.palette.colors[index]; // TODO: ase-parser doesn't give us the palette entry that represents transparent from the header
      // as described here: https://github.com/aseprite/aseprite/blob/master/docs/ase-file-specs.md#header
      // so we have to assume it's index 0 (which is the default, but the user can change it)

      if (index === 0) {
        return "rgba(0, 0, 0, 0)";
      }

      return "rgba(".concat(color.red, ", ").concat(color.green, ", ").concat(color.blue, ", ").concat(color.alpha / 255, ")");
    } else if (data.colorDepth === 16) {
      // grayscale
      var _offset2 = 2 * (x + cel.w * y);

      var value = cel.rawCelData[_offset2 + 0];
      var alpha = cel.rawCelData[_offset2 + 1];
      return "rgba(".concat(value, ", ").concat(value, ", ").concat(value, ", ").concat(alpha, ")");
    } else {
      throw new Error("Unsupported Aseprite color depth: ".concat(data.colorDepth));
    }
  }

  function convertFrameToImage(frame) {
    if (frameCache.has(frame)) {
      return frameCache.get(frame);
    }

    var canvas = document.createElement("canvas");
    canvas.width = size.x;
    canvas.height = size.y;
    var context = canvas.getContext("2d");

    if (!context) {
      throw new Error("Couldn't get 2d context for canvas");
    }

    var celsSortedByLayerIndex = frame.cels.sort(function (celA, celB) {
      return celA.layerIndex - celB.layerIndex;
    });
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = celsSortedByLayerIndex[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var cel = _step.value;

        if (cel.celType !== 0 && cel.celType !== 2) {
          throw new Error("Unsupported cel type: ".concat(cel.celType));
        }

        context.save();
        var alpha = cel.opacity / 255;
        var layer = data.layers[cel.layerIndex];

        if (layer) {
          alpha = alpha * (layer.opacity / 255);
          var blendMode = layer.blendMode;
          var compositeOperation = CANVAS_COMPOSITE_OPERATIONS_BY_BLEND_MODE[blendMode];

          if (compositeOperation) {
            context.globalCompositeOperation = compositeOperation;
          } else {
            var blendModeNiceName = LAYER_BLEND_MODES[blendMode];
            throw new Error("Unsupported Aseprite layer blending mode: ".concat(blendModeNiceName || blendMode));
          }
        }

        context.translate(cel.xpos, cel.ypos);
        context.globalAlpha = alpha;

        for (var i = 0; i < cel.w; i++) {
          for (var j = 0; j < cel.h; j++) {
            context.fillStyle = colorAtPixel(cel, i, j);
            context.fillRect(i, j, 1, 1);
          }
        }

        context.restore();
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    frameCache.set(frame, canvas);
    return canvas;
  }

  animations["default"] = useNewComponent(function () {
    return Animation(data.frames.map(function (frame) {
      return new AnimationFrame(convertFrameToImage(frame), {
        duration: frame.frameDuration
      });
    }));
  });
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    var _loop = function _loop() {
      var tag = _step2.value;
      var frames = data.frames.slice(tag.from, tag.to + 1);

      if (tag.animDirection === "Reverse") {
        frames.reverse();
      } else if (tag.animDirection === "Ping-pong") {
        frames = frames.concat(frames.slice(1).reverse().slice(1));
      }

      animations[tag.name] = useNewComponent(function () {
        return Animation(frames.map(function (frame) {
          return new AnimationFrame(convertFrameToImage(frame), {
            duration: frame.frameDuration
          });
        }));
      });
    };

    for (var _iterator2 = data.tags[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      _loop();
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  var currentAnim = animations["default"];

  var _useEnableDisable = useEnableDisable(),
      onEnabled = _useEnableDisable.onEnabled,
      onDisabled = _useEnableDisable.onDisabled;

  onEnabled(function () {
    Object.values(animations).forEach(function (animation) {
      return animation.enable();
    });
  });
  onDisabled(function () {
    Object.values(animations).forEach(function (animation) {
      return animation.disable();
    });
  });
  /** Draw the current animation frame into the provided canvas context. */

  function draw(context) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$x = _ref.x,
        x = _ref$x === void 0 ? 0 : _ref$x,
        _ref$y = _ref.y,
        y = _ref$y === void 0 ? 0 : _ref$y;

    var frame = currentAnim.currentFrame.data;
    context.drawImage(frame, x, y);
  }

  return {
    /** The current animation, that frames will be drawn from. */
    get currentAnim() {
      return currentAnim;
    },

    set currentAnim(nextValue) {
      currentAnim = nextValue;
    },

    /** The aseprite-loader data that was passed into this function. */
    data: data,

    /**
     * All the animations that were found in the Aseprite file.
     *
     * We use Tags to find these, and also include an animation called "default" which
     * is the animation containing every frame in the file, in order.
     */
    animations: animations,
    draw: draw,

    /** The maximum size of the frames in this Aseprite file. */
    size: size
  };
}