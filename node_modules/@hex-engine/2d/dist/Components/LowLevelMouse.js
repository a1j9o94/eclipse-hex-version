function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { useType, useEnableDisable, useCallbackAsCurrent } from "@hex-engine/core";
import { Vector } from "../Models";
import { useContext, useUpdate, useEntityTransforms } from "../Hooks";
/** A Mouse event in Hex Engine. */

export var HexMouseEvent =
/** The position of the cursor, relative to the current Entity's origin. */

/** The amount that the cursor has moved since the last frame. */

/** Which buttons were pressed during this event, or, in the case of a MouseUp event, which buttons were released. */
function HexMouseEvent(pos, delta, buttons) {
  _classCallCheck(this, HexMouseEvent);

  _defineProperty(this, "pos", void 0);

  _defineProperty(this, "delta", void 0);

  _defineProperty(this, "buttons", void 0);

  this.pos = pos;
  this.delta = delta;
  this.buttons = buttons;
};
var firstClickHasHappened = false;
var pendingFirstClickHandlers = [];
/**
 * This function will run the provided function the first time a mouse click occurs.
 * Note that it only works if there is at least one `Mouse` or `LowLevelMouse` Component
 * loaded in your game when the first click occurs. To be on the safe side, you should
 * probably also add a LowLevelMouse or Mouse Component to the Component that calls useFirstClick.
 */

export function useFirstClick(handler) {
  pendingFirstClickHandlers.push(useCallbackAsCurrent(handler));
  return {
    /** Whether the first click has occurred. */
    get firstClickHasHappened() {
      return firstClickHasHappened;
    }

  };
}
/**
 * A low-level Mouse Component. It supports mousemove, mousedown, and mouseup events.
 * For click events, information about whether the cursor is within an Entity's geometry,
 * and clean separation between left-click, right-click, and middle-click events, use `Mouse` instead.
 */

export default function LowLevelMouse() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$positionsRelativ = _ref.positionsRelativeTo,
      positionsRelativeTo = _ref$positionsRelativ === void 0 ? "owning-entity" : _ref$positionsRelativ;

  useType(LowLevelMouse);
  var storage = {
    moveCallbacks: new Set(),
    downCallbacks: new Set(),
    upCallbacks: new Set(),
    outCallbacks: new Set(),
    overCallbacks: new Set()
  };
  var context = useContext();
  var canvas = context.canvas;
  var transforms = useEntityTransforms();

  function translatePos(clientX, clientY) {
    var rect = canvas.getBoundingClientRect();
    var scaleX = rect.width / canvas.width;
    var scaleY = rect.height / canvas.height;
    var x = (clientX - rect.left) / scaleX;
    var y = (clientY - rect.top) / scaleY;
    var point = new Vector(x, y);

    switch (positionsRelativeTo) {
      case "screen":
        {
          return point;
        }

      case "world":
        {
          // screen -> world
          var canvasTransform = context.getTransform();
          point.transformUsingMatrixMutate(canvasTransform.inverse());
          return point;
        }

      case "owning-entity":
        {
          // screen -> world
          var _canvasTransform = context.getTransform();

          point.transformUsingMatrixMutate(_canvasTransform.inverse()); // world -> ent

          transforms.matrixForWorldPosition().inverse().transformPointMutate(point);
          return point;
        }
    }
  }

  var lastPos = new Vector(0, 0);
  var event = new HexMouseEvent(new Vector(0, 0), new Vector(0, 0), {
    left: false,
    right: false,
    middle: false,
    mouse4: false,
    mouse5: false
  });

  function updateEvent(_ref2) {
    var clientX = _ref2.clientX,
        clientY = _ref2.clientY,
        _ref2$buttons = _ref2.buttons,
        buttons = _ref2$buttons === void 0 ? 0 : _ref2$buttons,
        button = _ref2.button;
    event.pos = translatePos(clientX, clientY);
    event.delta.mutateInto(event.pos);
    event.delta.subtractMutate(lastPos);
    lastPos.mutateInto(event.pos);
    event.buttons.left = Boolean(buttons & 1) || button === 0;
    event.buttons.right = Boolean(buttons & 2) || button === 2;
    event.buttons.middle = Boolean(buttons & 4) || button === 1;
    event.buttons.mouse4 = Boolean(buttons & 8) || button === 3;
    event.buttons.mouse5 = Boolean(buttons & 16) || button === 4;
  }

  var _pendingMove2 = null;
  var _pendingOver = null;
  var _pendingOut = null;
  var _pendingDown2 = null;
  var _pendingUp2 = null;

  var handleMouseMove = function handleMouseMove(_ref3) {
    var clientX = _ref3.clientX,
        clientY = _ref3.clientY,
        buttons = _ref3.buttons;

    _pendingMove2 = function pendingMove() {
      _pendingMove2 = null;
      updateEvent({
        clientX: clientX,
        clientY: clientY,
        buttons: buttons
      });
      storage.moveCallbacks.forEach(function (callback) {
        return callback(event);
      });
    };
  };

  var handleMouseOver = function handleMouseOver(_ref4) {
    var clientX = _ref4.clientX,
        clientY = _ref4.clientY,
        buttons = _ref4.buttons;

    _pendingOver = function pendingOver() {
      _pendingOver = null;
      updateEvent({
        clientX: clientX,
        clientY: clientY,
        buttons: buttons
      });
      storage.overCallbacks.forEach(function (callback) {
        return callback(event);
      });
    };
  };

  var handleMouseOut = function handleMouseOut(_ref5) {
    var clientX = _ref5.clientX,
        clientY = _ref5.clientY,
        buttons = _ref5.buttons;

    _pendingOut = function pendingOut() {
      _pendingOut = null;
      updateEvent({
        clientX: clientX,
        clientY: clientY,
        buttons: buttons
      });
      storage.outCallbacks.forEach(function (callback) {
        return callback(event);
      });
    };
  };

  var handleMouseDown = function handleMouseDown(_ref6) {
    var clientX = _ref6.clientX,
        clientY = _ref6.clientY,
        button = _ref6.button;

    if (!firstClickHasHappened) {
      firstClickHasHappened = true;
      pendingFirstClickHandlers.forEach(function (handler) {
        handler();
      });
      pendingFirstClickHandlers = [];
    }

    _pendingDown2 = function pendingDown() {
      _pendingDown2 = null;
      updateEvent({
        clientX: clientX,
        clientY: clientY,
        button: button
      });
      storage.downCallbacks.forEach(function (callback) {
        return callback(event);
      });
    };
  };

  var handleMouseUp = function handleMouseUp(_ref7) {
    var clientX = _ref7.clientX,
        clientY = _ref7.clientY,
        button = _ref7.button;

    _pendingUp2 = function pendingUp() {
      _pendingUp2 = null;
      updateEvent({
        clientX: clientX,
        clientY: clientY,
        button: button
      });
      storage.upCallbacks.forEach(function (callback) {
        return callback(event);
      });
    };
  };

  var isTouching = false;

  var handleTouchStart = function handleTouchStart(ev) {
    ev.preventDefault();
    if (isTouching) return;

    if (!firstClickHasHappened) {
      firstClickHasHappened = true;
      pendingFirstClickHandlers.forEach(function (handler) {
        handler();
      });
      pendingFirstClickHandlers = [];
    }

    var touches = ev.touches;
    if (touches.length < 1) return;
    var _touches$ = touches[0],
        clientX = _touches$.clientX,
        clientY = _touches$.clientY;
    var button = 0;

    _pendingDown2 = function _pendingDown() {
      _pendingDown2 = null;
      updateEvent({
        clientX: clientX,
        clientY: clientY,
        button: button
      });
      storage.downCallbacks.forEach(function (callback) {
        return callback(event);
      });
    };

    isTouching = true;
  };

  var handleTouchMove = function handleTouchMove(ev) {
    ev.preventDefault();
    var touches = ev.touches;
    if (touches.length < 1) return;
    var _touches$2 = touches[0],
        clientX = _touches$2.clientX,
        clientY = _touches$2.clientY;
    var button = 0;

    _pendingMove2 = function _pendingMove() {
      _pendingMove2 = null;
      updateEvent({
        clientX: clientX,
        clientY: clientY,
        button: button
      });
      storage.moveCallbacks.forEach(function (callback) {
        return callback(event);
      });
    };
  };

  var handleTouchEnd = function handleTouchEnd(ev) {
    ev.preventDefault();
    if (!isTouching) return;
    var touches = ev.changedTouches;
    if (touches.length < 1) return;
    var _touches$3 = touches[0],
        clientX = _touches$3.clientX,
        clientY = _touches$3.clientY;
    var button = 0;

    _pendingUp2 = function _pendingUp() {
      _pendingUp2 = null;
      updateEvent({
        clientX: clientX,
        clientY: clientY,
        button: button
      });
      storage.upCallbacks.forEach(function (callback) {
        return callback(event);
      });
    };

    isTouching = false;
  };

  useUpdate(function () {
    // Very important that we process move before down/up, so that touch screens work
    if (_pendingMove2) _pendingMove2();
    if (_pendingOver) _pendingOver();
    if (_pendingOut) _pendingOut();
    if (_pendingDown2) _pendingDown2();
    if (_pendingUp2) _pendingUp2();
  });
  var bound = false;

  function bindListeners(canvas) {
    if (bound) return;
    canvas.addEventListener("mousemove", handleMouseMove);
    canvas.addEventListener("mousedown", handleMouseDown);
    canvas.addEventListener("mouseup", handleMouseUp);
    canvas.addEventListener("mouseover", handleMouseOver);
    canvas.addEventListener("mouseout", handleMouseOut);
    canvas.addEventListener("touchstart", handleTouchStart);
    canvas.addEventListener("touchmove", handleTouchMove);
    canvas.addEventListener("touchend", handleTouchEnd);
    bound = true;
  }

  function unbindListeners(canvas) {
    if (!bound) return;
    canvas.removeEventListener("mousemove", handleMouseMove);
    canvas.removeEventListener("mousedown", handleMouseDown);
    canvas.removeEventListener("mouseup", handleMouseUp);
    canvas.removeEventListener("touchstart", handleTouchStart);
    canvas.removeEventListener("touchmove", handleTouchMove);
    canvas.removeEventListener("touchend", handleTouchEnd);
    bound = false;
  }

  var _useEnableDisable = useEnableDisable(),
      onEnabled = _useEnableDisable.onEnabled,
      onDisabled = _useEnableDisable.onDisabled;

  onEnabled(function () {
    if (canvas) bindListeners(canvas);
  });
  onDisabled(function () {
    if (canvas) unbindListeners(canvas);
  });
  return {
    /** Registers the provided function to be called when the mouse cursor moves. */
    onMouseMove: function onMouseMove(callback) {
      storage.moveCallbacks.add(useCallbackAsCurrent(callback));
    },

    /** Registers the provided function to be called when any button on the mouse is pressed down. */
    onMouseDown: function onMouseDown(callback) {
      storage.downCallbacks.add(useCallbackAsCurrent(callback));
    },

    /** Registers the provided function to be called when any button on the mouse is released. */
    onMouseUp: function onMouseUp(callback) {
      storage.upCallbacks.add(useCallbackAsCurrent(callback));
    },

    /** Registers the provided function to be called when the mouse exits the canvas. */
    onCanvasLeave: function onCanvasLeave(callback) {
      storage.outCallbacks.add(useCallbackAsCurrent(callback));
    },

    /** Registers the provided function to be called when the mouse enters the canvas. */
    onCanvasEnter: function onCanvasEnter(callback) {
      storage.overCallbacks.add(useCallbackAsCurrent(callback));
    }
  };
}