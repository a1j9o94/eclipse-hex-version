function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import mem from "mem";
import { useType } from "@hex-engine/core";
import { useFilledPixelBounds } from "../Hooks";

/**
 * This Component measures various characters using the specified font in order to
 * provide a function which can accurately predict the render size of text on the page.
 *
 * It is rarely used directly; instead, use `BMFont` or `SystemFont`.
 */
export default function FontMetrics(impl) {
  useType(FontMetrics);
  var canvas = document.createElement("canvas");
  canvas.width = impl.getFontSize() * 26;
  canvas.height = impl.getFontSize() * 3;
  var context = canvas.getContext("2d");

  if (context == null) {
    throw new Error("Could not get 2d context from canvas");
  }

  function getMeasurements() {
    if (!impl.readyToDraw()) {
      return {
        baselineToMeanLine: 0,
        baselineToCapLine: 0,
        baselineToDescentLine: 0,
        baselineToAscentLine: 0,
        descentLineToAscentLine: 0,
        baselineToCJKTop: 0,
        baselineToCJKBottom: 0,
        CJKTopToCJKBottom: 0,
        height: 0
      };
    }

    context.fillStyle = "black";
    var size = impl.getFontSize();
    impl.drawText(context, "acemnorsuvwxz", {
      x: 0,
      y: size
    });
    var filledBounds = useFilledPixelBounds(context);
    var baseline = filledBounds.maxY;
    var meanLine = filledBounds.minY;
    context.clearRect(0, 0, context.canvas.width, context.canvas.height);
    impl.drawText(context, "gjypq", {
      x: 0,
      y: size
    });
    filledBounds = useFilledPixelBounds(context);
    var descentLine = filledBounds.maxY;
    context.clearRect(0, 0, context.canvas.width, context.canvas.height);
    impl.drawText(context, "fhijklt", {
      x: 0,
      y: size
    });
    filledBounds = useFilledPixelBounds(context);
    var ascendersLine = filledBounds.minY;
    context.clearRect(0, 0, context.canvas.width, context.canvas.height);
    impl.drawText(context, "ABCDEFGHIJKLMNOPQRSTUVWXYZ", {
      x: 0,
      y: size
    });
    filledBounds = useFilledPixelBounds(context);
    var capLine = filledBounds.minY;
    context.clearRect(0, 0, context.canvas.width, context.canvas.height);
    var ascentLine = Math.min(ascendersLine, capLine);
    impl.drawText(context, "你好。こんにちは。안녕하세요.", {
      x: 0,
      y: size
    });
    filledBounds = useFilledPixelBounds(context);
    var CJKTopLine = filledBounds.minY;
    var CJKBottomLine = filledBounds.maxY;
    return {
      baselineToMeanLine: baseline - meanLine,
      baselineToCapLine: baseline - capLine,
      baselineToDescentLine: descentLine - baseline,
      baselineToAscentLine: baseline - ascentLine,
      descentLineToAscentLine: descentLine - ascentLine,
      baselineToCJKBottom: CJKBottomLine - baseline,
      baselineToCJKTop: baseline - CJKTopLine,
      CJKTopToCJKBottom: CJKBottomLine - CJKTopLine,
      height: Math.max(descentLine, CJKBottomLine) - Math.min(ascentLine, CJKTopLine)
    };
  }

  return {
    measureText: mem(function (text) {
      if (!impl.readyToDraw()) {
        return {
          baselineToMeanLine: 0,
          baselineToCapLine: 0,
          baselineToDescentLine: 0,
          baselineToAscentLine: 0,
          descentLineToAscentLine: 0,
          baselineToCJKBottom: 0,
          baselineToCJKTop: 0,
          CJKTopToCJKBottom: 0,
          width: 0,
          height: 0
        };
      }

      var width = impl.measureWidth(text);
      var metrics = getMeasurements();
      return _objectSpread({}, metrics, {
        width: width
      });
    }, {
      cacheKey: function cacheKey(args) {
        return "".concat(impl.readyToDraw()).concat(impl.getFontSize()).concat(args[0]);
      }
    })
  };
}