import { useType, useNewComponent, useCallbackAsCurrent, useEntity } from "@hex-engine/core";
import { useEntitiesAtPoint, useUpdate } from "../Hooks";
import LowLevelMouse from "./LowLevelMouse";
import Geometry from "./Geometry";
import { Vector } from "../Models";
export default function MousePosition() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$entity = _ref.entity,
      entity = _ref$entity === void 0 ? useEntity() : _ref$entity,
      _ref$geometry = _ref.geometry,
      geometry = _ref$geometry === void 0 ? entity.getComponent(Geometry) : _ref$geometry;

  useType(MousePosition);

  function pointIsWithinBounds(localPoint) {
    if (!geometry) return false;
    var worldPoint = geometry.worldPosition().addMutate(localPoint);
    return useEntitiesAtPoint(worldPoint)[0] === entity;
  }

  var storage = {
    onEnterCallbacks: new Set(),
    onMoveCallbacks: new Set(),
    onLeaveCallbacks: new Set()
  };

  var _useNewComponent = useNewComponent(LowLevelMouse),
      onMouseMove = _useNewComponent.onMouseMove;

  var isInsideBounds = false;
  var position = new Vector(Infinity, Infinity);

  function handleEvent(event) {
    position.mutateInto(event.pos);
    storage.onMoveCallbacks.forEach(function (callback) {
      return callback(event);
    });

    if (pointIsWithinBounds(event.pos)) {
      if (!isInsideBounds) {
        storage.onEnterCallbacks.forEach(function (callback) {
          return callback(event);
        });
      }

      isInsideBounds = true;
    } else if (isInsideBounds) {
      storage.onLeaveCallbacks.forEach(function (callback) {
        return callback(event);
      });
      isInsideBounds = false;
    }
  }

  onMouseMove(handleEvent);
  var callbackSetters = {
    onEnter: function onEnter(callback) {
      storage.onEnterCallbacks.add(useCallbackAsCurrent(callback));
    },
    onMove: function onMove(callback) {
      storage.onMoveCallbacks.add(useCallbackAsCurrent(callback));
    },
    onLeave: function onLeave(callback) {
      storage.onLeaveCallbacks.add(useCallbackAsCurrent(callback));
    }
  };

  if (geometry) {
    // Handle the fact that isInsideBounds could change due to the entity moving
    // underneath the cursor.
    var lastEntPosition = geometry.position.clone();
    useUpdate(function () {
      var thisEntPosition = geometry.position;

      if (!thisEntPosition.equals(lastEntPosition)) {
        var diff = thisEntPosition.subtract(lastEntPosition);
        position.subtractMutate(diff);
        isInsideBounds = pointIsWithinBounds(position);
        lastEntPosition.mutateInto(thisEntPosition);
      }
    });
  }

  return {
    get isInsideBounds() {
      return isInsideBounds;
    },

    get position() {
      return position;
    },

    get onEnter() {
      return callbackSetters.onEnter;
    },

    get onMove() {
      return callbackSetters.onMove;
    },

    get onLeave() {
      return callbackSetters.onLeave;
    }

  };
}