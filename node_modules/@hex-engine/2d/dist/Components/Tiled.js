function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { useType, useNewComponent } from "@hex-engine/core";
import SpriteSheet from "./SpriteSheet";
import TileMap from "./TileMap";
import { Grid, Vector } from "../Models";

function getElementByTagName(parent, tagName) {
  if (typeof parent === "string") return null;
  if (!parent.children) return null;
  var maybeEl = parent.children.find(function (child) {
    return typeof child !== "string" && child.tagName === tagName;
  });

  if (maybeEl && typeof maybeEl !== "string") {
    return maybeEl;
  }

  return null;
}

function getElementsByTagName(parent, tagName) {
  if (typeof parent === "string") return [];
  if (!parent.children) return [];
  var els = parent.children.filter(function (child) {
    return typeof child !== "string" && child.tagName === tagName;
  }); // @ts-ignore

  return els;
}
/**
 * This Component loads data from a Tiled XML tileset file
 * and creates a `SpriteSheet` Component out of it.
 * @param data The tileset XML file
 */


function Tileset(data) {
  useType(Tileset);

  if (typeof data === "string" || data.tagName !== "tileset" || !data.children) {
    throw new Error("Invalid XML data passed to Tiled.Tileset");
  }

  var image = getElementByTagName(data, "image");

  if (!image || typeof image === "string") {
    throw new Error("XML data passed to Tiled.Tileset does not contain an image");
  }

  var imageUrl = image.attributes.source;

  if (typeof imageUrl !== "string") {
    throw new Error("source attribute of image in XML data passed to Tiled.Tileset is not a string");
  }

  var tileWidth = data.attributes.tilewidth;

  if (typeof tileWidth !== "number") {
    throw new Error("tilewidth attribute of tileset in XML data passed to Tiled.Tileset is not a number");
  }

  var tileHeight = data.attributes.tileheight;

  if (typeof tileHeight !== "number") {
    throw new Error("tileheight attribute of tileset in XML data passed to Tiled.Tileset is not a number");
  }

  var spriteSheet = useNewComponent(function () {
    return SpriteSheet({
      url: imageUrl,
      tileWidth: Number(tileWidth) || 0,
      tileHeight: Number(tileHeight) || 0
    });
  });
  return {
    spriteSheet: spriteSheet
  };
}
/**
 * This Component represents the data for a single layer within a Tiled map XML file.
 *
 * You'll rarely create it directly; instead, you'll get it from a Tiled.Map.
 *
 * @param layer The layer XML element
 */


function Layer(layer) {
  useType(Layer);

  if (typeof layer === "string" || layer.tagName !== "layer") {
    throw new Error("Invalid XML data passed to Tiled.Layer");
  }

  var width = layer.attributes.width;

  if (typeof width !== "number") {
    throw new Error("`width` attribute in XML data passed to Tiled.Layer was not a number");
  }

  var height = layer.attributes.height;

  if (typeof height !== "number") {
    throw new Error("`height` attribute in XML data passed to Tiled.Layer was not a number");
  }

  var dataEl = getElementByTagName(layer, "data");
  var layerFormat = 'xml';

  if (!dataEl || typeof dataEl === "string") {
    throw new Error("`data` element not found in XML data passed to Tiled.Layer");
  } // Layer formatting in tiled is XML by default and all other formats have the `encoding` attr


  if (dataEl.attributes.hasOwnProperty('encoding')) {
    if (dataEl.attributes.encoding === 'csv') {
      layerFormat = 'csv';
    } else {
      throw new Error("Unexpected layer data passed to Tiled.Layer. Only XML and CSV encoding is supported at this time.");
    }
  }

  var grid = new Grid(width, height, 0);
  var numbers = [];

  if (dataEl.children) {
    if (layerFormat === 'xml') {
      var tileEls = getElementsByTagName(dataEl, 'tile');
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = tileEls[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var tileEl = _step.value;

          if (tileEl.attributes.hasOwnProperty('gid')) {
            numbers.push(tileEl.attributes.gid);
          } else {
            numbers.push(0);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    } else if (layerFormat === 'csv') {
      var csv = dataEl.children.join(" ");
      numbers = csv.split(",").map(function (cell) {
        return Number(cell.trim());
      }).map(function (tileIndex) {
        return tileIndex - 1;
      });
    }
  }

  grid.setData(numbers);
  return {
    grid: grid,
    visible: layer.attributes.visible !== 0
  };
}

function makeTiledObject(object) {
  useType(TiledMap);

  if (typeof object === "string") {
    return {
      kind: "string",
      object: object
    };
  }

  var api = {
    id: object.attributes.id,
    name: object.attributes.name,
    location: new Vector(Number(object.attributes.x), Number(object.attributes.y)),
    size: object.attributes.width && object.attributes.height ? new Vector(Number(object.attributes.width), Number(object.attributes.height)) : undefined,
    object: object,
    properties: []
  };
  var maybePropertiesEl = getElementByTagName(object, "properties");

  if (maybePropertiesEl) {
    var properties = getElementsByTagName(maybePropertiesEl, "property");
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = properties[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var child = _step2.value;
        api.properties.push({
          name: child.attributes.name,
          value: child.attributes.value,
          type: child.attributes.type
        });
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }

  var maybePointEl = getElementByTagName(object, "point");

  if (maybePointEl) {
    return _objectSpread({}, api, {
      kind: "point"
    });
  }

  var maybeEllipseEl = getElementByTagName(object, "ellipse");

  if (maybeEllipseEl) {
    return _objectSpread({}, api, {
      kind: "ellipse"
    });
  }

  var maybeTextEl = getElementByTagName(object, "text");

  if (maybeTextEl) {
    return _objectSpread({}, api, {
      kind: "text"
    });
  }

  var maybePolygonEl = getElementByTagName(object, "polygon");

  if (maybePolygonEl) {
    return _objectSpread({}, api, {
      kind: "polygon",
      points: maybePolygonEl.attributes.points.split(" ").map(function (pairString) {
        return pairString.split(",");
      }).map(function (pair) {
        return new Vector(Number(pair[0]), Number(pair[1]));
      })
    });
  }

  return _objectSpread({}, api, {
    kind: "unknown"
  });
}
/**
 * This Component loads data from a Tiled map XML file and creates
 * SpriteSheet and TileMap Components that you can use to draw the
 * map into the canvas.
 *
 * @param data The Tiled map XML file
 */


function TiledMap(data) {
  var _tilesetEl$children;

  useType(TiledMap);

  if (typeof data === "string" || data.tagName !== "map") {
    throw new Error("Invalid XML data passed to Tiled.Map");
  }

  var tilesetEl = getElementByTagName(data, "tileset");

  if (!tilesetEl || typeof tilesetEl === "string") {
    throw new Error("tileset not found in XML data passed to Tiled.Map");
  } // Assign source based on if tileset is embedded or not


  var tilesetSource = (tilesetEl === null || tilesetEl === void 0 ? void 0 : (_tilesetEl$children = tilesetEl.children) === null || _tilesetEl$children === void 0 ? void 0 : _tilesetEl$children.length) ? tilesetEl : tilesetEl.attributes.source;
  var tileset = useNewComponent(function () {
    return Tileset(tilesetSource);
  });
  var layerEls = data.children ? data.children.filter(function (child) {
    return typeof child !== "string" && child.tagName === "layer";
  }) : [];
  var layers = [];
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    var _loop = function _loop() {
      var layerEl = _step3.value;
      layers.push(useNewComponent(function () {
        return Layer(layerEl);
      }));
    };

    for (var _iterator3 = layerEls[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      _loop();
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  var tileMaps = layers.filter(function (layer) {
    return layer.visible;
  }).map(function (layer) {
    return useNewComponent(function () {
      return TileMap(tileset.spriteSheet, layer.grid);
    });
  });
  var maxX = layers.reduce(function (prev, layer) {
    return Math.max(prev, layer.grid.size.x);
  }, 0);
  var maxY = layers.reduce(function (prev, layer) {
    return Math.max(prev, layer.grid.size.y);
  }, 0);
  var sizeInTiles = new Vector(maxX, maxY);
  var sizeInPixels = sizeInTiles.multiply(tileset.spriteSheet.tileSize);
  var objectGroups = data.children ? data.children.filter(function (child) {
    return typeof child !== "string" && child.tagName === "objectgroup";
  }) : [];
  var objects = [];
  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    for (var _iterator4 = objectGroups[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      var objectGroup = _step4.value;
      if (typeof objectGroup === "string") continue;
      if (!objectGroup.children) continue;
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = objectGroup.children[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var object = _step5.value;
          if (typeof object === "string") continue;
          objects.push(object);
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
            _iterator5["return"]();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
        _iterator4["return"]();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }

  return {
    /** The tileset used by the map */
    tileset: tileset,

    /** An Array of Tiled.Layer Compponents, each corresponding to a layer in the Tiled map */
    layers: layers,

    /** An Array of TileMap Components, each corresponding to a *visible* layer in the Tiled map */
    tileMaps: tileMaps,

    /** The size of the map in tiles */
    sizeInTiles: sizeInTiles,

    /** The size of the map in pixels */
    sizeInPixels: sizeInPixels,

    /** The size of a single tile in the map */
    tileSize: tileset.spriteSheet.tileSize,

    /** All the objects that were present in the map, for you to use however you like */
    objects: objects.map(function (obj) {
      return makeTiledObject(obj);
    })
  };
}

Object.defineProperty(Tileset, "name", {
  value: "Tiled.Tileset"
});
Object.defineProperty(Layer, "name", {
  value: "Tiled.Layer"
});
Object.defineProperty(TiledMap, "name", {
  value: "Tiled.Map"
});
export { Tileset, Layer, TiledMap as Map };