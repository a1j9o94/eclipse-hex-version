import { useType } from "@hex-engine/core";
import { useInspectorHoverOutline } from "../Hooks";
import { Polygon } from "../Models";

var textToTokens = function textToTokens(text) {
  return text.replace(/\n/g, " _-_LINE_BREAK_-_ ").replace(/\t/g, " _-_TAB_-_ ").split(/ /); // TODO: doesn't work for CJK, where there's no spaces
};

var tokensToText = function tokensToText(tokens) {
  return tokens.join(" ").replace(/ _-_LINE_BREAK_-_ /g, "\n").replace(/ _-_TAB_-_ /g, "\t");
};
/**
 * This Component lays out text in lines, fitting as many words as it can on
 * one line before continue onto the next. When you use it, it tells you which
 * lines it rendered, and which parts of the text you provided didn't fit into
 * the text box (if any). You can use this information to re-render the text
 * box with new content, once the user has read the text.
 */


export default function TextBox(_ref) {
  var font = _ref.font,
      size = _ref.size,
      receivedLineHeight = _ref.lineHeight;
  useType(TextBox);
  var shape = Polygon.rectangle(size);
  useInspectorHoverOutline(function () {
    return shape;
  });
  return {
    /**
     * Draws as much of the provided text as will fit into the textbox,
     * then returns information about how much text was drawn.
     */
    drawText: function drawText(context, text) {
      var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          _ref2$x = _ref2.x,
          x = _ref2$x === void 0 ? 0 : _ref2$x,
          _ref2$y = _ref2.y,
          y = _ref2$y === void 0 ? 0 : _ref2$y;

      if (!font.readyToDraw()) return {
        didTextFit: false,
        remainingText: text,
        printedLines: []
      };
      var lineHeight = receivedLineHeight;

      if (lineHeight == null) {
        var metrics = font.measureText("AaBbGgJjYyあい。");
        lineHeight = metrics.height;
      }

      var tokens = textToTokens(text);
      var seenTokens = [];
      var lines = [];
      var didTextFit = true;
      var remainingText = "";

      while (tokens.length > 0 && (lines.length + 1) * lineHeight < size.y) {
        var widthSoFarOnLine = 0;
        var line = "";

        while (tokens.length > 0 && widthSoFarOnLine < size.x) {
          var token = tokens.shift();

          if (token === "_-_LINE_BREAK_-_") {
            seenTokens.push(token);
            break;
          }

          if (token === "_-_TAB_-_") {
            token = "    ";
          }

          var addition = line ? " " + token : token;
          var additionWidth = font.measureText(addition).width;

          if (widthSoFarOnLine + additionWidth < size.x) {
            line += addition;
            widthSoFarOnLine += additionWidth;
            seenTokens.push(token);
          } else {
            tokens.unshift(token);
            break;
          }
        }

        if (tokens.length > 0) {
          didTextFit = false;
          remainingText = tokensToText(tokens);
        } else {
          didTextFit = true;
          remainingText = "";
        }

        lines.push(line);
      }

      lines.forEach(function (line, index) {
        var lineOffset = lineHeight * index;
        context.textBaseline = "top";
        font.drawText(context, line, {
          x: x,
          y: y + lineOffset
        });
      });
      return {
        /** A boolean indicating whether all the text that was provided fit into the textbox. */
        didTextFit: didTextFit,

        /** A string containing any remaining text that didn't fit into the box. */
        remainingText: remainingText,

        /** An Array containing all the lines that were printed. */
        printedLines: lines
      };
    }
  };
}