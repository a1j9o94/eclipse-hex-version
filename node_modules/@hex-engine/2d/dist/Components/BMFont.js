function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { useType, useNewComponent } from "@hex-engine/core"; // @ts-ignore

import createLayout from "layout-bmfont-text";
import Image from "./Image";
import Font from "./Font";
import FontMetrics from "./FontMetrics";
/** This Component uses an AngelCode BMFont-format file to render text into the canvas. */

export default function BMFont(data) {
  useType(BMFont);
  var images = data.pages.map(function (page) {
    return useNewComponent(function () {
      return Image({
        url: page
      });
    });
  });
  var layout = createLayout({
    font: data,
    text: ""
  });
  var api = {
    /** Whether all the images the font references have been loaded yet. */
    readyToDraw: function readyToDraw() {
      return images.every(function (image) {
        return image.loaded;
      });
    },

    /** Measures how many pixels wide the specified text would be, if it was rendered using this font. */
    measureWidth: function measureWidth(text) {
      layout.update({
        font: data,
        text: text,
        mode: "pre"
      });
      return layout.width;
    },

    /** Returns this font's size. */
    getFontSize: function getFontSize() {
      return data.info.size;
    },

    /** Draws some text into the canvas, using this font. */
    drawText: function drawText(context, text) {
      var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          _ref$x = _ref.x,
          x = _ref$x === void 0 ? 0 : _ref$x,
          _ref$y = _ref.y,
          y = _ref$y === void 0 ? 0 : _ref$y;

      layout.update({
        font: data,
        text: text
      });
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = layout.glyphs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var glyph = _step.value;
          var image = images[glyph.data.page];

          if (!image) {
            throw new Error("BMFont referenced out-of-bounds page");
          }

          if (!image.data) return;
          image.draw(context, {
            x: glyph.position[0] + x + glyph.data.xoffset,
            y: glyph.position[1] + y + glyph.data.yoffset,
            sourceX: glyph.data.x,
            sourceY: glyph.data.y,
            sourceWidth: glyph.data.width,
            sourceHeight: glyph.data.height,
            targetWidth: glyph.data.width,
            targetHeight: glyph.data.height
          });
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  };
  var fontMetrics = useNewComponent(function () {
    return FontMetrics(api);
  });

  var fontApi = _objectSpread({}, api, {
    /** Draws some text into the canvas, using this font. */
    drawText: function drawText(context, text) {
      var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          _ref2$x = _ref2.x,
          x = _ref2$x === void 0 ? 0 : _ref2$x,
          _ref2$y = _ref2.y,
          y = _ref2$y === void 0 ? 0 : _ref2$y,
          _ref2$baseline = _ref2.baseline,
          baseline = _ref2$baseline === void 0 ? undefined : _ref2$baseline;

      var measurements = fontMetrics.measureText(text);
      var yOffset = {
        alphabetic: 0,
        bottom: -Math.max(measurements.baselineToDescentLine, measurements.baselineToCJKBottom),
        hanging: measurements.baselineToMeanLine + measurements.baselineToAscentLine / 2.5,
        // guesstimate cause I don't get hanging
        ideographic: measurements.baselineToCJKBottom,
        middle: -measurements.baselineToDescentLine + measurements.descentLineToAscentLine / 2,
        top: Math.max(measurements.baselineToAscentLine, measurements.baselineToCJKTop)
      }[baseline || context.textBaseline];
      api.drawText(context, text, {
        x: x,
        y: y + yOffset
      });
    },
    measureText: fontMetrics.measureText
  });

  useNewComponent(function () {
    return Font(fontApi);
  });
  return _objectSpread({
    /** The BMFont file data passed into this Component. */
    data: data,

    /** All the Image Components that this Component created in order to load the font. */
    images: images
  }, fontApi);
}