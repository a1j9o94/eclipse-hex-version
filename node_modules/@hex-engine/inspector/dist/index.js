function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

import React from "react";
import ReactDOM from "react-dom";
import { useRootEntity, useCallbackAsCurrent, useType, RunLoop, useNewComponent, ErrorBoundary } from "@hex-engine/core";
import debounce from "lodash.debounce";
import setWith from "lodash.setwith";
import get from "lodash.get";
import useForceUpdate from "use-force-update";
import App from "./App";
import useInspectorHover from "./useInspectorHover";
import useInspectorSelect from "./useInspectorSelect";

// Chrome throws an error when localStorage is not available, even if all you do
// is check if it's undefined. So this approach is needed.
var initialInspectorTree = function () {
  try {
    return localStorage.inspectorTree ? JSON.parse(localStorage.inspectorTree) : {
      root: {}
    };
  } catch (err) {
    return {
      root: {}
    };
  }
}();

function saveTree(tree) {
  localStorage.inspectorTree = JSON.stringify(tree);
}

var debouncedSaveTree = debounce(saveTree, 100);

function getRootToEntityPath(entity) {
  var path = [];
  var ent = entity;

  while (ent.parent) {
    var idx = _toConsumableArray(ent.parent.children).indexOf(ent);

    path.push(idx, "children");
    ent = ent.parent;
  }

  path.push("root");
  path.reverse();
  return path;
}

function Root(_ref) {
  var entity = _ref.entity,
      runLoop = _ref.runLoop,
      stateHolder = _ref.stateHolder;
  var forceUpdate = useForceUpdate();
  stateHolder.forceUpdate = forceUpdate;
  return React.createElement(App, {
    entity: entity,
    getSelectedEntity: stateHolder.getSelectedEntity,
    runLoop: runLoop,
    error: stateHolder.err,
    getExpanded: stateHolder.getExpanded,
    onExpand: stateHolder.setExpanded,
    isHovered: stateHolder.isHovered,
    isOpen: stateHolder.getIsOpen(),
    toggleOpen: stateHolder.toggleOpen,
    isSelectMode: stateHolder.getSelectMode(),
    toggleSelectMode: stateHolder.toggleSelectMode,
    collapseTree: stateHolder.collapseTree
  });
}
/**
 * A Component function that renders an Inspector overlay onto the page,
 * that shows you information about the current Entity tree, and allows you
 * to tweak values and pause/resume/step frame execution.
 *
 * It stores its state (which things are opened, whether you are paused, etc)
 * in localStorage, so that state persists across page refreshes.
 *
 * Note that the Inspector is pretty performance-heavy while open.
 *
 * Since the Inspector lowers the framerate while open, and allows you to
 * tweak Component and Entity values arbitrarily, you probably don't want
 * to include it in your final game release.
 */


export default function Inspector() {
  useType(Inspector);
  var pauseOnStart = localStorage.inspectorPauseOnStart === "true";
  var rootEntity = useRootEntity();
  var runLoop = rootEntity.getComponent(RunLoop);
  var isOpen = localStorage.inspectorOpen === "true";
  var isSelectMode = false;
  var tree = initialInspectorTree;
  var selectedEntity = null;
  var stateHolder = {
    tree: tree,
    setExpanded: function setExpanded(path, expand) {
      if (expand) {
        setWith(tree, path, {}, Object);
      } else {
        var key = path.pop(); // lodash.get(obj, []) does not return obj. We need to test if we
        // reached the root and manually collapse it

        if (key === "root") {
          stateHolder.collapseTree();
        } else {
          var subtree = get(tree, path);
          delete subtree[key];
        }
      }

      debouncedSaveTree(tree);
    },
    getExpanded: function getExpanded(path) {
      return get(tree, path) !== undefined;
    },
    collapseTree: function collapseTree() {
      tree.root = {};
    },
    err: null,
    forceUpdate: null,
    isHovered: false,
    getIsOpen: function getIsOpen() {
      return isOpen;
    },
    toggleOpen: function toggleOpen() {
      isOpen = !isOpen;
      localStorage.inspectorOpen = isOpen;
    },
    getSelectMode: function getSelectMode() {
      return isSelectMode;
    },
    toggleSelectMode: function toggleSelectMode() {
      return isSelectMode = !isSelectMode;
    },
    getSelectedEntity: function getSelectedEntity() {
      return selectedEntity;
    },
    selectEntity: function selectEntity(entity) {
      if (!stateHolder.getIsOpen()) {
        stateHolder.toggleOpen();
      }

      var entityPath = getRootToEntityPath(entity);
      stateHolder.setExpanded(entityPath, true);
      selectedEntity = entity;
    }
  };
  useNewComponent(function () {
    return ErrorBoundary(function (err) {
      console.error(err, err.stack);
      stateHolder.err = err;
      runLoop === null || runLoop === void 0 ? void 0 : runLoop.pause();

      if (stateHolder.forceUpdate) {
        stateHolder.forceUpdate();
      }
    });
  });
  var hasPausedOnStart = false;
  var el = document.createElement("div");
  document.body.appendChild(el);

  var _useInspectorHover = useInspectorHover(),
      onHoverStart = _useInspectorHover.onHoverStart,
      onHoverEnd = _useInspectorHover.onHoverEnd;

  onHoverStart(function () {
    stateHolder.isHovered = true;
    if (stateHolder.forceUpdate) stateHolder.forceUpdate();
  });
  onHoverEnd(function () {
    stateHolder.isHovered = false;
    if (stateHolder.forceUpdate) stateHolder.forceUpdate();
  });
  ReactDOM.render(React.createElement(Root, {
    entity: rootEntity,
    runLoop: runLoop,
    stateHolder: stateHolder
  }), el, useCallbackAsCurrent(function () {
    var tick = useCallbackAsCurrent(function () {
      if (runLoop && pauseOnStart && !hasPausedOnStart) {
        runLoop.pause();
        hasPausedOnStart = true;
      }

      if (stateHolder.forceUpdate != null) {
        stateHolder.forceUpdate();
      }

      requestAnimationFrame(tick);
    });
    tick();
  }));
  var getSelectMode = stateHolder.getSelectMode,
      toggleSelectMode = stateHolder.toggleSelectMode,
      selectEntity = stateHolder.selectEntity;
  var inspectorSelectApi = {
    getSelectMode: getSelectMode,
    toggleSelectMode: toggleSelectMode,
    selectEntity: selectEntity
  };
  return _objectSpread({}, inspectorSelectApi, {
    hide: function hide() {
      el.style.visibility = "hidden";
    },
    show: function show() {
      el.style.visibility = "";
    }
  });
}
export { useInspectorHover, useInspectorSelect };