function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

import React, { useState, useRef, useEffect } from "react";
export default function EditableString(_ref) {
  var color = _ref.color,
      value = _ref.value,
      _onChange = _ref.onChange,
      expanded = _ref.expanded;

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      isEditing = _useState2[0],
      setIsEditing = _useState2[1];

  var _useState3 = useState(value),
      _useState4 = _slicedToArray(_useState3, 2),
      editedValue = _useState4[0],
      setEditedValue = _useState4[1];

  var measureWidthRef = useRef(null);
  var inputRef = useRef(null);
  var TagName = expanded ? "textarea" : "input";
  useEffect(function () {
    if (expanded) return;
    var measureWidth = measureWidthRef.current;
    var input = inputRef.current;
    if (!measureWidth) return;
    if (!input) return;
    measureWidth.style.display = "inline";
    var rect = measureWidth.getBoundingClientRect();
    measureWidth.style.display = "none";
    input.style.width = rect.width + "px";
  }, [editedValue, value]);
  var currentValue = isEditing ? editedValue : value;
  return React.createElement(React.Fragment, null, React.createElement("span", {
    style: {
      display: "none"
    },
    ref: measureWidthRef,
    className: "measure-width"
  }, currentValue), React.createElement(TagName // @ts-ignore
  , {
    ref: inputRef,
    style: {
      color: color,
      font: "inherit",
      maxWidth: "200px"
    },
    value: currentValue,
    onFocus: function onFocus() {
      setEditedValue(value);
      setIsEditing(true);
    },
    onChange: function onChange(event) {
      if (!expanded && measureWidthRef.current) {
        event.target.style.width = measureWidthRef.current.getBoundingClientRect().width + "px";
      }

      setEditedValue(event.target.value);

      _onChange(event.target.value);
    },
    onBlur: function onBlur() {
      setIsEditing(false);
    },
    onKeyDown: function onKeyDown(event) {
      if (String(Number(currentValue)) !== currentValue) return;
      var delta = 0;

      if (event.key === "ArrowDown") {
        delta = -1;
      } else if (event.key === "ArrowUp") {
        delta = 1;
      }

      if (event.shiftKey && event.altKey) {
        delta *= Math.PI / 16;
      } else if (event.shiftKey) {
        delta *= 10;
      } else if (event.altKey) {
        delta *= 0.1;
      }

      var newValue = String(Number(currentValue) + delta);
      setEditedValue(newValue);

      _onChange(newValue);
    }
  }));
}