"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Calculates the Q value for a bandpass Biquad filter that achieves the given decay rate.
 * @param frequency The frequency property of the Biquad filter
 * @param decay The desired duration in seconds that it takes for the sound to decrease in volume by 60db
 * @param audioContext The audio context to measure the sample rate from
 */
function qFromdecay(frequency, decay, audioContext) {
    var rad = Math.pow(10, -3 / (decay * audioContext.sampleRate));
    var BW = Math.log(rad) / -Math.PI / (1 / audioContext.sampleRate);
    var Q = frequency / BW;
    return Q;
}
/**
 * Create a pair of input/output AudioNodes that filters an input excitation (for example, a short
 * burst of white noise, or residue noise gathered from a recording) into
 * one of the components of a modal sound.
 * @param frequency The center frequency of the mode in Hz
 * @param amplitude A number from 0-1; how loud this particular mode is
 * @param decay How long in seconds it takes for this mode to decrease in volume by 60db
 * @param audioContext The audioContext used to create nodes.
 */
function makeMode(frequency, amplitude, decay, audioContext) {
    var biquadFilter = audioContext.createBiquadFilter();
    biquadFilter.type = "bandpass";
    biquadFilter.frequency.value = frequency;
    biquadFilter.Q.value = qFromdecay(frequency, decay, audioContext);
    var ampMultiplier = audioContext.createGain();
    ampMultiplier.gain.value = amplitude;
    biquadFilter.connect(ampMultiplier);
    return {
        inputNode: biquadFilter,
        outputNode: ampMultiplier,
        disconnect: function () {
            biquadFilter.disconnect();
            ampMultiplier.disconnect();
        },
    };
}
/**
 * Create a pair of input/output AudioNodes that filters an input excitation (for example, a short
 * burst of white noise, or residue noise gathered from a recording) into
 * the described components of a modal sound.
 * @param data An array of objects with frequency/amplitude/decay properties that describe the modes.
 * - frequency: The center frequency of the mode in Hz
 * - amplitude: A number from 0-1; how loud this particular mode is
 * - decay: How long in seconds it takes for this mode to decrease in volume by 60db
 * @param audioContext The AudioContext used to create nodes.
 */
function makeModes(data, audioContext) {
    var e_1, _a;
    var modes = data.map(function (datum) {
        return makeMode(datum.frequency, datum.amplitude, datum.decay, audioContext);
    });
    var input = audioContext.createGain();
    input.gain.value = 1;
    var output = audioContext.createGain();
    input.gain.value = 1;
    try {
        for (var modes_1 = __values(modes), modes_1_1 = modes_1.next(); !modes_1_1.done; modes_1_1 = modes_1.next()) {
            var mode = modes_1_1.value;
            input.connect(mode.inputNode);
            mode.outputNode.connect(output);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (modes_1_1 && !modes_1_1.done && (_a = modes_1.return)) _a.call(modes_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return {
        inputNode: input,
        outputNode: output,
        disconnect: function () {
            var e_2, _a;
            input.disconnect();
            output.disconnect();
            try {
                for (var modes_2 = __values(modes), modes_2_1 = modes_2.next(); !modes_2_1.done; modes_2_1 = modes_2.next()) {
                    var mode = modes_2_1.value;
                    mode.disconnect();
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (modes_2_1 && !modes_2_1.done && (_a = modes_2.return)) _a.call(modes_2);
                }
                finally { if (e_2) throw e_2.error; }
            }
        },
    };
}
exports.default = makeModes;
