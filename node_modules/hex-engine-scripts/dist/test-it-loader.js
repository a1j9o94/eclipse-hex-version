"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = defaultLoader;

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var babel = _interopRequireWildcard(require("@babel/core"));

var _mimeTypes = _interopRequireDefault(require("mime-types"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function runSimpleWebpackLoader(webpackLoader, filepath) {
  var ctx = {
    resourcePath: filepath
  };

  if (webpackLoader.raw) {
    var _source = _fs["default"].readFileSync(filepath);

    return webpackLoader.call(ctx, _source);
  } else {
    var _source2 = _fs["default"].readFileSync(filepath, "utf-8");

    return webpackLoader.call(ctx, _source2);
  }
}

function defaultLoader(filename) {
  var extension = _path["default"].extname(filename);

  switch (extension) {
    case ".ase":
    case ".aseprite":
      {
        return runSimpleWebpackLoader(require("aseprite-loader"), filename);
      }

    case ".xml":
      {
        return runSimpleWebpackLoader(require("xml-source-loader"), filename);
      }

    case ".fnt":
      {
        return runSimpleWebpackLoader(require("bmfont-loader"), filename);
      }

    case ".json":
      {
        return runSimpleWebpackLoader(require("ogmo-level-json-loader"), filename);
      }

    case ".css":
      {
        // This imitates style-loader
        var content = _fs["default"].readFileSync(filename, "utf-8");

        return "\n        var style = document.createElement(\"style\");\n        style.type = \"text/css\";\n        style.textContent = ".concat(JSON.stringify(content), ";\n        document.head.appendChild(style);\n      ");
      }

    case ".ogmo":
      {
        return runSimpleWebpackLoader(require("ogmo-project-loader"), filename);
      }

    case ".js":
    case ".jsx":
    case ".mjs":
    case ".ts":
    case ".tsx":
      {
        var config;

        if (filename.match(/node_modules/)) {
          // We need to always compile ESM to CJS, because @hex-engine
          // packages are published with ESM, but test-it can't run
          // ESM unless the loader compiles it to CJS. Its default loader
          // compiles ESM to CJS, but not for node_modules (for speed).
          //
          // The reason @hex-engine packages are published with ESM
          // is because it allows webpack to treeshake unused named
          // exports, which reduces the size of published games
          // drastically, because it removes unused component functions.
          //
          // We could relax this to only compile node_modules/@hex-engine,
          // but I want third-party hex-engine component libraries to be
          // able to benefit from tree-shaking, too.
          config = {
            compact: true,
            plugins: ["@babel/plugin-transform-modules-commonjs"]
          };
        } else {
          config = {
            compact: false,
            sourceType: "unambiguous",
            presets: [["@babel/preset-env", {
              modules: false,
              targets: {
                node: "current"
              }
            }], "@babel/preset-typescript", "@babel/preset-react"],
            plugins: ["@babel/plugin-proposal-class-properties", "@babel/plugin-proposal-nullish-coalescing-operator", "@babel/plugin-proposal-optional-chaining", "@babel/plugin-transform-modules-commonjs"],
            filename: filename
          };
        }

        var result = babel.transformFileSync(filename, config);
        return (result === null || result === void 0 ? void 0 : result.code) || "";
      }

    default:
      {
        // This imitates url-loader, standing in place of file-loader
        var type = _mimeTypes["default"].lookup(extension) || "application/octet-stream";

        var base64 = _fs["default"].readFileSync(filename, "base64");

        var url = "data:".concat(type, ";base64,").concat(base64);
        return "module.exports = ".concat(JSON.stringify(url));
      }
  }
}