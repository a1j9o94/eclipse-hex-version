"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var fs_1 = __importDefault(require("fs"));
var path_1 = __importDefault(require("path"));
var crypto_1 = __importDefault(require("crypto"));
var mkdirp_1 = __importDefault(require("mkdirp"));
var chalk_1 = __importDefault(require("chalk"));
var uid_1 = __importDefault(require("uid"));
var t = __importStar(require("@babel/types"));
var generator_1 = __importDefault(require("@babel/generator"));
var parser = __importStar(require("@babel/parser"));
var traverse_1 = __importDefault(require("@babel/traverse"));
var code_frame_1 = require("@babel/code-frame");
var bundle_wrapper_1 = require("./bundle-wrapper");
var bake_node_env_1 = __importDefault(require("./bake-node-env"));
function makeBundler(config) {
    return /** @class */ (function () {
        function Bundler() {
            this._pendingChunks = [];
            this._warnings = [];
        }
        Bundler.prototype._transformRequires = function (filename, code) {
            var resolvedRequires = [];
            var pendingChunks = this._pendingChunks;
            var warnings = this._warnings;
            var ast = parser.parse(code);
            traverse_1.default(ast, {
                CallExpression: function (nodePath) {
                    var node = nodePath.node;
                    var hasOneStringArg = node.arguments.length === 1 && t.isStringLiteral(node.arguments[0]);
                    var isRequire = t.isIdentifier(node.callee) && node.callee.name === "require";
                    var isImport = t.isImport(node.callee);
                    if (isRequire || isImport) {
                        if (!hasOneStringArg) {
                            warnings.push(chalk_1.default.yellow("Found a non-static " + (isRequire ? "require" : "import") + " in '" + filename + "'. This cannot be bundled, and will be left as-is.") +
                                "\n" +
                                code_frame_1.codeFrameColumns(code, node.loc, { highlightCode: true }));
                            return;
                        }
                        // @ts-ignore
                        var source = nodePath.get("arguments")[0];
                        var currentValue = source.node.value;
                        var newValueAbsolute = void 0;
                        try {
                            newValueAbsolute = config.resolver(currentValue, filename, {});
                        }
                        catch (err) {
                            var newMessage = chalk_1.default.red("Resolver failed in") + " " + chalk_1.default.yellow("'" + filename + "'") + ": " +
                                err.message +
                                "\n" +
                                code_frame_1.codeFrameColumns(code, node.loc, { highlightCode: true });
                            Object.defineProperty(err, "message", { value: newMessage });
                            throw err;
                        }
                        var newValue = path_1.default.relative(process.cwd(), newValueAbsolute);
                        if (isRequire) {
                            resolvedRequires.push(newValue);
                            nodePath.replaceWith(t.callExpression(t.identifier("_kame_require_"), [
                                t.stringLiteral(newValue),
                            ]));
                        }
                        else {
                            pendingChunks.push(newValue);
                            nodePath.replaceWith(t.callExpression(t.identifier("_kame_dynamic_import_"), [
                                t.stringLiteral(newValue),
                            ]));
                        }
                    }
                },
            });
            return {
                transformedCode: generator_1.default(ast).code,
                resolvedRequires: resolvedRequires,
            };
        };
        Bundler.prototype._gatherModules = function (entry) {
            var modules = {};
            var filesToProcess = [];
            filesToProcess.push(entry);
            var file;
            while ((file = filesToProcess.shift())) {
                if (file.startsWith("external:")) {
                    modules[file] = "module.exports = require(" + JSON.stringify(file.replace(/^external:/, "")) + ")";
                    continue;
                }
                var absFile = path_1.default.resolve(process.cwd(), file);
                var code = void 0;
                try {
                    code = config.loader(absFile);
                }
                catch (err) {
                    var newMessage = chalk_1.default.red("Loader failed to load") + " " + chalk_1.default.yellow("'" + absFile + "'") + ": " + err.message;
                    Object.defineProperty(err, "message", { value: newMessage });
                    throw err;
                }
                try {
                    code = bake_node_env_1.default(code, process.env.NODE_ENV || "production");
                }
                catch (err) {
                    this._warnings.push(chalk_1.default.yellow("Warning: Kame bundler failed to bake process.env.NODE_ENV into the generated code for '" + absFile + "'.\n" + err));
                }
                var _a = this._transformRequires(file, code), transformedCode = _a.transformedCode, resolvedRequires = _a.resolvedRequires;
                modules[file] = transformedCode;
                filesToProcess.push.apply(filesToProcess, __spread(resolvedRequires));
            }
            return modules;
        };
        Bundler.prototype.bundle = function (_a) {
            var input = _a.input, output = _a.output, globalName = _a.globalName, _b = _a.codeSplittingId, codeSplittingId = _b === void 0 ? uid_1.default() + Date.now() : _b;
            this._pendingChunks = [];
            this._warnings = [];
            var writtenFiles = [];
            if (!path_1.default.isAbsolute(input)) {
                input = path_1.default.resolve(process.cwd(), input);
            }
            if (!path_1.default.isAbsolute(output)) {
                output = path_1.default.resolve(process.cwd(), output);
            }
            mkdirp_1.default.sync(path_1.default.dirname(output));
            var relativeInput = path_1.default.relative(process.cwd(), input);
            var entryModules = this._gatherModules(relativeInput);
            var chunkUrls = {};
            var needsRegenerator = false;
            var pendingChunk;
            var _loop_1 = function () {
                var chunkModules = this_1._gatherModules(pendingChunk);
                Object.keys(chunkModules).forEach(function (key) {
                    if (entryModules[key]) {
                        delete chunkModules[key];
                    }
                });
                var chunkHash = crypto_1.default
                    .createHash("md5")
                    .update(Object.values(chunkModules).join("\n") + codeSplittingId)
                    .digest("hex");
                var chunkOutputFilename = chunkHash + ".js";
                chunkUrls[pendingChunk] = chunkOutputFilename;
                var chunkOutputPath = path_1.default.join(path_1.default.dirname(output), chunkOutputFilename);
                var chunkCode = bundle_wrapper_1.chunkWrapper({
                    entryId: pendingChunk,
                    codeSplittingId: codeSplittingId,
                    modules: chunkModules,
                });
                if (chunkCode.match(/regeneratorRuntime/)) {
                    needsRegenerator = true;
                }
                fs_1.default.writeFileSync(chunkOutputPath, chunkCode);
                writtenFiles.push(chunkOutputPath);
            };
            var this_1 = this;
            while ((pendingChunk = this._pendingChunks.shift())) {
                _loop_1();
            }
            var entryCode = bundle_wrapper_1.entryWrapper({
                entryId: relativeInput,
                globalName: globalName,
                codeSplittingId: codeSplittingId,
                modules: entryModules,
                chunkUrls: chunkUrls,
            });
            if (entryCode.match(/regeneratorRuntime/)) {
                needsRegenerator = true;
            }
            if (needsRegenerator) {
                var regeneratorCode = fs_1.default.readFileSync(require.resolve("regenerator-runtime"), "utf-8");
                entryCode = regeneratorCode + ";\n" + entryCode;
            }
            fs_1.default.writeFileSync(output, entryCode);
            writtenFiles.push(output);
            return {
                warnings: this._warnings,
                writtenFiles: writtenFiles,
            };
        };
        return Bundler;
    }());
}
exports.default = makeBundler;
