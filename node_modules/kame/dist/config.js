"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var path_1 = __importDefault(require("path"));
var util_1 = __importDefault(require("util"));
var debug_1 = __importDefault(require("debug"));
var default_loader_1 = __importDefault(require("./default-loader"));
var defaultResolver = __importStar(require("./default-resolver"));
var default_runtime_eval_1 = __importDefault(require("./default-runtime-eval"));
var debug = debug_1.default("kame/config");
function loadFile(filepath) {
    var resolvedPath;
    try {
        resolvedPath = defaultResolver.resolve(filepath, path_1.default.join(process.cwd(), "fake-cwd-file.js"), {});
    }
    catch (err) {
        try {
            resolvedPath = defaultResolver.resolve("./" + filepath, path_1.default.join(process.cwd(), "fake-cwd-file.js"), {});
        }
        catch (err2) {
            throw err;
        }
    }
    return require(resolvedPath);
}
function readConfig(inputConfig) {
    debug("Parsing input config: " + util_1.default.inspect(inputConfig));
    // @ts-ignore
    var config = {};
    if (typeof inputConfig.loader === "string") {
        var mod = loadFile(inputConfig.loader);
        if (typeof mod === "object" && mod != null && mod.__esModule) {
            config.loader = mod.default;
        }
        else {
            config.loader = mod;
        }
        if (typeof config.loader !== "function") {
            throw new Error("'" + inputConfig.loader + "' did not export a function as either its default export or module.exports. Loader modules should export a function that receives an absolute path string and returns a JavaScript code string.");
        }
    }
    else if (typeof inputConfig.loader === "function") {
        config.loader = inputConfig.loader;
    }
    else {
        config.loader = default_loader_1.default;
    }
    if (typeof inputConfig.resolver === "string") {
        var mod = loadFile(inputConfig.resolver);
        if (typeof mod === "object" && mod != null) {
            config.resolver = mod.resolve;
        }
        if (typeof config.resolver !== "function") {
            throw new Error("'" + inputConfig.resolver + "' did not export a function as its 'resolve' named export. Resolver modules should adhere to the eslint-plugin-import resolver spec v2 as defined at https://github.com/benmosher/eslint-plugin-import/blob/b916ed2b574a107e62f819663b8c300f82d82d8d/resolvers/README.md.");
        }
    }
    else if (typeof inputConfig === "function") {
        config.resolver = inputConfig;
    }
    else {
        config.resolver = defaultResolver.resolve;
    }
    if (typeof inputConfig.runtimeEval === "string") {
        var mod = loadFile(inputConfig.runtimeEval);
        if (typeof mod === "object" && mod != null && mod.__esModule) {
            config.runtimeEval = mod.default;
        }
        else {
            config.runtimeEval = mod;
        }
        if (typeof config.runtimeEval !== "function") {
            throw new Error("'" + inputConfig.runtimeEval + "' did not export a function as either its default export or module.exports. Runtime eval modules should export a function that receives a code string and an absolute path string and returns the result of evaluating that code string as an expression.");
        }
    }
    else if (typeof inputConfig.runtimeEval === "function") {
        config.runtimeEval = inputConfig.runtimeEval;
    }
    else {
        config.runtimeEval = default_runtime_eval_1.default;
    }
    debug("Parsed input config: " + util_1.default.inspect(config));
    return config;
}
exports.readConfig = readConfig;
