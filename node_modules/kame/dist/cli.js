#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var fs_1 = __importDefault(require("fs"));
var path_1 = __importDefault(require("path"));
var chalk_1 = __importDefault(require("chalk"));
var yargs_parser_1 = __importDefault(require("yargs-parser"));
var index_1 = require("./index");
var argv = yargs_parser_1.default(process.argv.slice(2), {
    boolean: ["help"],
    string: [
        "input",
        "output",
        "global",
        "loader",
        "resolver",
        "runtime-eval",
        "runtimeEval",
        "codeSplittingId",
        "code-splitting-id",
    ],
});
function getInput(argv) {
    var input = argv.input || argv._[1];
    if (!input) {
        var pathsToTry = [
            path_1.default.join(process.cwd(), "src", "index.tsx"),
            path_1.default.join(process.cwd(), "src", "index.ts"),
            path_1.default.join(process.cwd(), "src", "index.jsx"),
            path_1.default.join(process.cwd(), "src", "index.js"),
            path_1.default.join(process.cwd(), "index.tsx"),
            path_1.default.join(process.cwd(), "index.ts"),
            path_1.default.join(process.cwd(), "index.jsx"),
            path_1.default.join(process.cwd(), "index.js"),
        ];
        var pathToUse = null;
        while (!pathToUse && pathsToTry.length > 0) {
            var nextPath = pathsToTry.shift();
            if (!nextPath)
                break;
            if (fs_1.default.existsSync(nextPath)) {
                pathToUse = nextPath;
            }
        }
        if (pathToUse) {
            input = pathToUse;
            console.warn("Auto-detected '" + path_1.default.relative(process.cwd(), pathToUse) + "' as the input file. Use --input to override.");
        }
        else {
            console.error("Could not auto-detect the input file. Please specify it with --input.");
            console.error("Run with --help for more info.");
            process.exit(1);
        }
    }
    return input;
}
function getOutput(argv) {
    var output = argv.output || argv._[2];
    if (!output) {
        output = path_1.default.join(process.cwd(), "dist", "index.js");
        console.warn("Using default output path of './dist/index.js'. Use --output to override.");
    }
    return output;
}
var usage = "Usage: kame <command> [options]\n\n<command>: What to do. Can be 'run' or 'bundle'.\n\nOptions:\n--input: The file to run, or the bundle entrypoint.\n\n         If left unspecified, kame will attempt to use whichever of these files\n         exists, in order:\n\n         - ./src/index.tsx\n         - ./src/index.ts\n         - ./src/index.jsx\n         - ./src/index.js\n         - ./index.tsx\n         - ./index.ts\n         - ./index.jsx\n         - ./index.js\n\n--output: The file to write bundle output to.\n\n          If left unspecified, kame will default to './dist/index.js'.\n\n          Note: If you use code splitting (dynamic import), then the\n          split chunks will be written into the same folder as the\n          output file, with autogenerated names. For this reason, you\n          may want the output file to be in something like a 'dist' or\n          'build' folder.\n\n--global: The name of the global variable that the bundle contents should\n          be written to, if the bundle is loaded in an environment without\n          a module loader. If you pass the string \"null\", then no global\n          will be written.\n\n          If left unspecified, no global variable will be written.\n\n--loader: The path to a file that exports a loader function, which kame will\n          use to read modules from disk and convert them to JavaScript.\n\n          A loader module should export a function that receives a\n          string (the file to load), and returns a string (the code to\n           execute in the browser). Loader modules must be synchronous,\n           because they're called when 'require' is called.\n\n          Defaults to 'node_modules/kame/dist/default-loader.js',\n          which supports ES2020, React, TypeScript, and Flow.\n\n--resolver: The path to a file that exports a resolver function, which kame\n            will use to convert the strings appearing in requires and imports\n            into absolute paths to files on disk.\n\n            The resolver function should be defined according to the\n            eslint-plugin-import resolver spec v2 as defined at the\n            following url:\n\n            https://github.com/benmosher/eslint-plugin-import/blob/b916ed2b574a107e62f819663b8c300f82d82d8d/resolvers/README.md\n\n            Defaults to 'node_modules/kame/dist/default-resolver.js', which\n            implements node's module resolution algorithm, and supports\n            omitting the extension in the import/require for any of these\n            filetypes: \".js\", \".json\", \".mjs\", \".jsx\", \".ts\", and \".tsx\".\n\n--runtime-eval: The path to a file that exports an eval function, which kame\n                will use to execute code (in run mode only).\n\n                The eval function will receive:\n                - A code string (always an expression)\n                - The absolute path to the file where the code came from\n\n                And should return:\n                - The result of evaluating the code string\n\n                Defaults to 'node_modules/kame/dist/default-runtime-eval.js',\n                which uses node's builtin `vm` module to run code.\n\n--code-splitting-id: A globally-unique id used to tie code-split chunks from\n                     this bundle to the correct kame instance.\n\n                     When using dynamic import syntax (`import()`), kame\n                     splits your code into separate files, some of which have\n                     generated filenames. These files are called \"chunks\".\n\n                     The first chunk that gets loaded is called the \"entry\"\n                     chunk. The entry chunk sets up a module cache and loader\n                     that other chunks then hook into in order to load modules\n                     at a later time. This module cache and loader is called\n                     the \"kame instance\".\n\n                     If your code contains two separate kame bundles,\n                     and they both use dynamic imports, then kame needs a way\n                     to tell some chunks \"go use this kame instance\" and\n                     other chunks \"go use that kame instance\".\n\n                     That's where the code-splitting id comes in. It's a\n                     globally-unique identifier that can be used to\n                     differentiate one kame instance from another.\n\n                     When kame compiles a bundle, every chunk in it includes\n                     the code-splitting id.\n\n                     The code-splitting id defaults to an autogenerated unique\n                     id. But, if you want your chunks to be separately cacheable\n                     for browsers (so that unchanged chunks don't need to be\n                     redownloaded), you'll need to set your own code-splitting\n                     id.\n\n                     If you aren't using code-splitting, you don't need to\n                     care about this.\n";
if (argv.help) {
    console.log(usage);
    process.exitCode = 1;
}
else {
    var inputConfig = {
        loader: argv.loader,
        resolver: argv.resolver,
        runtimeEval: argv.runtimeEval,
    };
    var kame = index_1.configure(inputConfig);
    if (argv._[0] === "run") {
        var input = getInput(argv);
        console.warn("Running " + (path_1.default.isAbsolute(input) ? path_1.default.relative(process.cwd(), input) : input));
        var runtime = new kame.Runtime();
        runtime.load(argv.input || argv._[1]);
    }
    else if (argv._[0] === "bundle") {
        var input = getInput(argv);
        var output = getOutput(argv);
        var globalName = argv.global;
        if (globalName === undefined)
            globalName = null;
        if (globalName === "null")
            globalName = null;
        var codeSplittingId = argv.codeSplittingId || undefined;
        var bundler = new kame.Bundler();
        var _a = bundler.bundle({
            input: input,
            output: output,
            globalName: globalName,
            codeSplittingId: codeSplittingId,
        }), warnings = _a.warnings, writtenFiles = _a.writtenFiles;
        warnings.forEach(function (warning) {
            console.warn(warning);
        });
        console.warn(chalk_1.default.blue("Files created:"));
        writtenFiles.forEach(function (file) {
            console.log(path_1.default.relative(process.cwd(), file));
        });
    }
    else {
        console.error("Unknown command: " + argv._[0] + "\n");
        console.error(usage);
        process.exitCode = 1;
    }
}
